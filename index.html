<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="color-scheme" content="dark light" />
  <title>JPuz — Crear y Jugar (100% local)</title>
  <style>
    :root{
      --bg0:#07090b;
      --bg1:#0c1216;
      --panel:rgba(12,16,20,.82);
      --line:rgba(255,255,255,.10);
      --line2:rgba(255,255,255,.14);
      --text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.68);
      --muted2:rgba(255,255,255,.54);
      --good:#22c55e;
      --warn:#f59e0b;
      --bad:#ef4444;

      --btn:rgba(255,255,255,.09);
      --btnH:rgba(255,255,255,.13);
      --btnA:rgba(255,255,255,.18);

      --shadow: 0 18px 60px rgba(0,0,0,.42);
      --radius: 14px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      --sans: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      --frame: rgba(255,255,255,.22);

      --feltBase:#0b1b2b;
      --feltGlow:rgba(110,180,255,.10);
    }
    body[data-theme="blue"]{ --feltBase:#0b1b2b; --feltGlow:rgba(110,180,255,.10); }
    body[data-theme="slate"]{ --feltBase:#121416; --feltGlow:rgba(220,220,220,.08); }
    body[data-theme="forest"]{ --feltBase:#0c1b12; --feltGlow:rgba(120,255,170,.10); }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family:var(--sans);
      background:
        radial-gradient(1200px 800px at 12% 10%, rgba(255,255,255,.05), transparent 60%),
        radial-gradient(900px 700px at 90% 5%, rgba(255,255,255,.04), transparent 60%),
        linear-gradient(180deg, var(--bg1), var(--bg0));
      color:var(--text);
      overflow:hidden;
    }

    /* Topbar */
    #topbar{
      height:64px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding:10px 12px;
      background: rgba(10,14,18,.82);
      border-bottom:1px solid var(--line);
      backdrop-filter: blur(10px);
      position:relative;
      z-index:10;
    }
    #brand{
      display:flex; align-items:center; gap:10px;
      min-width: 210px;
    }
    #logo{
      width:34px;height:34px;border-radius:10px;
      background:
        radial-gradient(circle at 30% 30%, rgba(255,255,255,.28), rgba(255,255,255,.10) 40%, rgba(0,0,0,.18) 70%),
        linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.03));
      border:1px solid rgba(255,255,255,.12);
      box-shadow: 0 10px 26px rgba(0,0,0,.30);
    }
    #brandText{ line-height:1.12; }
    #brandText b{ font-size:14px; letter-spacing:.2px; }
    #brandText span{ display:block; font-size:12px; color:var(--muted2); }

    #centerBar{
      flex:1;
      display:flex;
      align-items:center;
      justify-content:center;
      gap:10px;
      min-width:0;
    }
    #statusPill{
      display:flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.07);
      max-width: 60vw;
      min-width: 220px;
    }
    #statusDot{
      width:9px;height:9px;border-radius:99px;
      background: rgba(255,255,255,.50);
      box-shadow: 0 0 0 3px rgba(255,255,255,.06);
      flex:0 0 auto;
    }
    #statusText{
      font-size:13px;
      color:var(--muted);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    #timer{
      font-family:var(--mono);
      font-size:14px;
      padding:7px 10px;
      border-radius:12px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.22);
      min-width:100px;
      text-align:center;
    }

    .btn{
      appearance:none;
      border:1px solid var(--line);
      background: var(--btn);
      color:var(--text);
      padding:8px 10px;
      border-radius:12px;
      cursor:pointer;
      transition: background .15s ease, transform .05s ease, border-color .15s ease;
      display:inline-flex;
      align-items:center;
      gap:8px;
      user-select:none;
      white-space:nowrap;
      font-size:13px;
    }
    .btn:hover{ background: var(--btnH); border-color: var(--line2); }
    .btn:active{ transform: translateY(1px); background: var(--btnA); }
    .btn[disabled]{ opacity:.5; cursor:not-allowed; }
    .k{
      font-family:var(--mono);
      font-size:11px;
      color:var(--muted2);
      border:1px solid var(--line);
      padding:2px 6px;
      border-radius:8px;
      background: rgba(0,0,0,.18);
    }
    .btnPrimary{
      background: rgba(34,197,94,.14);
      border-color: rgba(34,197,94,.28);
    }
    .btnPrimary:hover{ background: rgba(34,197,94,.20); border-color: rgba(34,197,94,.34); }

    #rightControls{
      display:flex; align-items:center; gap:8px;
      min-width: 260px;
      justify-content:flex-end;
    }

    /* Layout */
    #layout{
      height: calc(100% - 64px);
      display:grid;
      grid-template-columns: 360px 1fr;
      min-height:0;
    }
    #panel{
      border-right:1px solid var(--line);
      background: rgba(10,14,18,.62);
      backdrop-filter: blur(10px);
      min-height:0;
      overflow:auto;
      padding:12px;
    }
    .tabs{
      display:flex;
      gap:8px;
      margin-bottom:12px;
    }
    .tab{
      flex:1;
      text-align:center;
      padding:10px;
      border-radius:12px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.06);
      color:var(--muted);
      cursor:pointer;
      user-select:none;
      font-size:13px;
    }
    .tab.active{
      color:var(--text);
      background: rgba(255,255,255,.12);
      border-color: var(--line2);
    }

    .card{
      background: rgba(255,255,255,.04);
      border:1px solid var(--line);
      border-radius: var(--radius);
      padding:12px;
      box-shadow: 0 14px 46px rgba(0,0,0,.22);
      margin-bottom:12px;
    }
    .card h3{
      margin:0 0 10px 0;
      font-size:13px;
      letter-spacing:.2px;
    }
    label{
      display:flex;
      flex-direction:column;
      gap:6px;
      font-size:12px;
      color:var(--muted);
      margin-bottom:10px;
    }
    input[type="text"], input[type="password"], input[type="number"], select, input[type="file"]{
      width:100%;
      padding:10px 10px;
      border-radius:12px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.22);
      color:var(--text);
      outline:none;
    }
    input[type="file"]{
      border-style:dashed;
      background: rgba(0,0,0,.14);
    }
    .grid2{ display:grid; grid-template-columns:1fr 1fr; gap:10px; }
    .row{ display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap; }
    .hint{
      font-size:12px;
      color:var(--muted2);
      line-height:1.35;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:7px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.18);
      font-family:var(--mono);
      font-size:11px;
      color:var(--muted2);
    }

    /* Board */
    #board{
      position:relative;
      overflow:hidden;
      background:
        radial-gradient(1100px 800px at 16% 22%, var(--feltGlow), transparent 55%),
        radial-gradient(900px 700px at 84% 20%, rgba(255,255,255,.05), transparent 60%),
        linear-gradient(180deg, rgba(255,255,255,.06), rgba(0,0,0,.10)),
        linear-gradient(180deg, var(--feltBase), rgba(0,0,0,.35));
    }
    #canvasHost{
      position:absolute;
      inset:0;
      /* important para móvil: evita scroll/zoom del navegador al arrastrar */
      touch-action: none;
      outline:none;
    }
    #targetFrame{
      position:absolute;
      left:50%;
      top:50%;
      transform: translate(-50%,-50%);
      border-radius: 16px;
      border: 2px dashed var(--frame);
      background: rgba(0,0,0,.04);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.25);
      pointer-events:none;
    }
    #targetFrame::after{
      content:"Marco guía";
      position:absolute;
      left:12px;
      top:10px;
      font-size:11px;
      color: rgba(255,255,255,.58);
      background: rgba(0,0,0,.22);
      border:1px solid rgba(255,255,255,.12);
      padding:5px 8px;
      border-radius:999px;
    }

    /* Overlay */
    #overlay{
      position:absolute;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      z-index:20;
      padding:18px;
    }
    #overlay.active{ display:flex; }
    #overlay.lock .backdrop{ background: rgba(0,0,0,.92); }
    .backdrop{
      position:absolute; inset:0;
      background: rgba(0,0,0,.70);
      backdrop-filter: blur(10px);
    }
    .modal{
      position:relative;
      width:min(760px, 100%);
      max-height:min(86vh, 860px);
      overflow:auto;
      border-radius: 18px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(12,16,20,.96);
      box-shadow: var(--shadow);
      padding:14px;
    }
    .modal h2{
      margin:0 0 8px 0;
      font-size:16px;
      letter-spacing:.2px;
    }
    .modal .content{
      color:var(--muted);
      font-size:13px;
      line-height:1.45;
    }
    .modal .actions{
      display:flex;
      justify-content:flex-end;
      gap:10px;
      margin-top:12px;
      flex-wrap:wrap;
    }
    .modal img{
      width:100%;
      max-height:58vh;
      object-fit:contain;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
      display:block;
      margin-top:10px;
    }
    .spinner{
      width:14px;height:14px;
      border-radius:99px;
      border:2px solid rgba(255,255,255,.18);
      border-top-color: rgba(255,255,255,.85);
      display:inline-block;
      animation: spin .8s linear infinite;
      vertical-align:-2px;
      margin-right:8px;
    }
    @keyframes spin{ to{ transform:rotate(360deg);} }

    /* Responsive */
    @media (max-width: 920px){
      body{ overflow:auto; }
      #layout{
        grid-template-columns: 1fr;
        grid-template-rows: auto 1fr;
        height:auto;
      }
      #panel{
        border-right:none;
        border-bottom:1px solid var(--line);
      }
      #rightControls{ min-width:0; }
      #brand{ min-width:0; }
      #statusPill{ max-width: 50vw; min-width: 180px; }
    }
  </style>
</head>

<body data-theme="blue">
  <header id="topbar" aria-label="Controles">
    <div id="brand">
      <div id="logo" aria-hidden="true"></div>
      <div id="brandText">
        <b>JPuz</b>
        <span>Crear · compartir .jpuz · jugar (local)</span>
      </div>
    </div>

    <div id="centerBar">
      <div id="statusPill" aria-live="polite" aria-atomic="true">
        <span id="statusDot" aria-hidden="true"></span>
        <span id="statusText">Cargando librerías…</span>
      </div>
      <div id="timer" title="Tiempo restante (mm:ss)">
        <span id="timeText">--:--</span>
      </div>
    </div>

    <div id="rightControls">
      <button class="btn" id="btnBoxTop" title="Box top (B)" disabled>Box top <span class="k">B</span></button>
      <button class="btn" id="btnPause" title="Pausar/Reanudar (P)" disabled>Pausa <span class="k">P</span></button>
      <button class="btn" id="btnTheme" title="Cambiar tema (T)">Tema <span class="k">T</span></button>
      <button class="btn" id="btnReframe" title="Reencuadrar (R)" disabled>Reencuadrar <span class="k">R</span></button>
      <button class="btn" id="btnFull" title="Pantalla completa">⛶</button>
    </div>
  </header>

  <div id="layout">
    <aside id="panel">
      <div class="tabs" role="tablist" aria-label="Modo">
        <div class="tab active" id="tabCreate" role="tab" aria-selected="true" tabindex="0">Crear</div>
        <div class="tab" id="tabPlay" role="tab" aria-selected="false" tabindex="0">Jugar</div>
      </div>

      <!-- CREATE -->
      <section id="paneCreate">
        <div class="card">
          <h3>Crear reto</h3>
          <label>Imagen (local)
            <input id="cImage" type="file" accept="image/*" />
          </label>

          <div class="grid2">
            <label>Piezas X (2–30)
              <input id="cX" type="number" min="2" max="30" value="8" />
            </label>
            <label>Piezas Y (2–30)
              <input id="cY" type="number" min="2" max="30" value="6" />
            </label>
          </div>

          <div class="grid2">
            <label>Tiempo límite (s)
              <input id="cSolve" type="number" min="10" value="300" />
            </label>
            <label>Reveal al completar (s)
              <input id="cReveal" type="number" min="0" value="6" />
            </label>
          </div>

          <div class="grid2">
            <label>Tema inicial
              <select id="cTheme">
                <option value="blue">Azul</option>
                <option value="slate">Pizarra</option>
                <option value="forest">Bosque</option>
              </select>
            </label>
            <label style="gap:8px;">
              Mystery mode
              <div class="row" style="justify-content:flex-start;">
                <input id="cMystery" type="checkbox" />
                <span class="hint">Desactiva box top</span>
              </div>
            </label>
          </div>

          <div class="grid2">
            <label>Max dimensión (px)
              <input id="cMaxDim" type="number" min="256" max="4096" value="1600" />
            </label>
            <label>Calidad JPEG (0.5–1.0)
              <input id="cQ" type="number" min="0.5" max="1" step="0.05" value="0.85" />
            </label>
          </div>

          <label>Título (opcional)
            <input id="cTitle" type="text" placeholder="Ej: Atardecer" />
          </label>

          <label>Contraseña (mín. 8)
            <input id="cPwd" type="password" minlength="8" placeholder="********" />
          </label>

          <div class="row">
            <button class="btn btnPrimary" id="btnGenerate" type="button">Generar .jpuz</button>
            <span class="pill" id="createInfo">—</span>
          </div>

          <p class="hint" style="margin:10px 0 0 0;">
            Privacidad práctica: tras descifrar, alguien puede capturar pantalla. No es evitable al 100%.
          </p>
        </div>
      </section>

      <!-- PLAY -->
      <section id="panePlay" style="display:none;">
        <div class="card">
          <h3>Jugar reto</h3>
          <label>Archivo .jpuz
            <input id="pFile" type="file" accept=".jpuz,application/json" />
          </label>
          <label>Contraseña
            <input id="pPwd" type="password" minlength="8" placeholder="********" />
          </label>
          <div class="row">
            <button class="btn btnPrimary" id="btnStart" type="button">Descifrar y jugar</button>
            <button class="btn" id="btnRestart" type="button" disabled>Reiniciar</button>
          </div>

          <p class="hint" style="margin:10px 0 0 0;">
            Atajos: <b>B</b> box top · <b>P</b> pausa · <b>T</b> tema · <b>R</b> reencuadrar · <b>Esc</b> cerrar overlays
          </p>
        </div>

        <div class="card">
          <h3>Diagnóstico rápido (si no cargan librerías)</h3>
          <p class="hint" style="margin:0;">
            Si tu red bloquea CDNs, añade en tu repo:
            <br>• <code>vendor/konva.min.js</code>
            <br>• <code>vendor/headbreaker.js</code>
            <br>El loader de esta página los intentará usar automáticamente.
          </p>
        </div>
      </section>
    </aside>

    <main id="board" aria-label="Mesa de trabajo">
      <div id="canvasHost" tabindex="0" aria-label="Puzzle"></div>
      <div id="targetFrame" aria-hidden="true"></div>

      <div id="overlay" role="dialog" aria-modal="true" aria-live="assertive">
        <div class="backdrop"></div>
        <div class="modal">
          <h2 id="ovTitle">—</h2>
          <div class="content" id="ovBody"></div>
          <div class="actions" id="ovActions"></div>
        </div>
      </div>
    </main>
  </div>

  <script>
  (() => {
    "use strict";

    // -----------------------------
    // DOM
    // -----------------------------
    const $ = (s, el=document) => el.querySelector(s);

    const el = {
      statusDot: $("#statusDot"),
      statusText: $("#statusText"),
      timeText: $("#timeText"),

      tabCreate: $("#tabCreate"),
      tabPlay: $("#tabPlay"),
      paneCreate: $("#paneCreate"),
      panePlay: $("#panePlay"),

      cImage: $("#cImage"),
      cX: $("#cX"),
      cY: $("#cY"),
      cSolve: $("#cSolve"),
      cReveal: $("#cReveal"),
      cTheme: $("#cTheme"),
      cMystery: $("#cMystery"),
      cMaxDim: $("#cMaxDim"),
      cQ: $("#cQ"),
      cTitle: $("#cTitle"),
      cPwd: $("#cPwd"),
      btnGenerate: $("#btnGenerate"),
      createInfo: $("#createInfo"),

      pFile: $("#pFile"),
      pPwd: $("#pPwd"),
      btnStart: $("#btnStart"),
      btnRestart: $("#btnRestart"),

      btnBoxTop: $("#btnBoxTop"),
      btnPause: $("#btnPause"),
      btnTheme: $("#btnTheme"),
      btnReframe: $("#btnReframe"),
      btnFull: $("#btnFull"),

      board: $("#board"),
      canvasHost: $("#canvasHost"),
      targetFrame: $("#targetFrame"),

      overlay: $("#overlay"),
      ovTitle: $("#ovTitle"),
      ovBody: $("#ovBody"),
      ovActions: $("#ovActions"),
    };

    // -----------------------------
    // UI helpers
    // -----------------------------
    function setStatus(text, kind="neutral"){
      el.statusText.textContent = text;
      const c = (kind==="good") ? "rgba(34,197,94,.95)"
              : (kind==="warn") ? "rgba(245,158,11,.95)"
              : (kind==="bad")  ? "rgba(239,68,68,.95)"
              : "rgba(255,255,255,.55)";
      el.statusDot.style.background = c;
      el.statusDot.style.boxShadow = (kind==="good") ? "0 0 0 3px rgba(34,197,94,.14)"
                                : (kind==="warn") ? "0 0 0 3px rgba(245,158,11,.14)"
                                : (kind==="bad")  ? "0 0 0 3px rgba(239,68,68,.14)"
                                : "0 0 0 3px rgba(255,255,255,.06)";
    }

    function showOverlay({title, html, actions=[], lock=false}){
      el.ovTitle.textContent = title || "—";
      el.ovBody.innerHTML = html || "";
      el.ovActions.innerHTML = "";
      el.overlay.classList.toggle("lock", !!lock);
      el.overlay.classList.add("active");

      for (const a of actions){
        const b = document.createElement("button");
        b.className = "btn " + (a.primary ? "btnPrimary" : "");
        b.textContent = a.label;
        b.addEventListener("click", () => a.onClick && a.onClick());
        el.ovActions.appendChild(b);
      }
    }
    function hideOverlay(force=false){
      if (!force && el.overlay.classList.contains("lock")) return;
      el.overlay.classList.remove("active","lock");
      el.ovTitle.textContent = "—";
      el.ovBody.innerHTML = "";
      el.ovActions.innerHTML = "";
    }
    el.overlay.addEventListener("click", (e) => {
      if (el.overlay.classList.contains("lock")) return;
      if (e.target === el.overlay || e.target.classList.contains("backdrop")) hideOverlay(false);
    });

    // -----------------------------
    // Tabs
    // -----------------------------
    function setTab(which){
      const create = which === "create";
      el.tabCreate.classList.toggle("active", create);
      el.tabPlay.classList.toggle("active", !create);
      el.paneCreate.style.display = create ? "" : "none";
      el.panePlay.style.display = create ? "none" : "";
      el.tabCreate.setAttribute("aria-selected", String(create));
      el.tabPlay.setAttribute("aria-selected", String(!create));
    }
    el.tabCreate.addEventListener("click", () => setTab("create"));
    el.tabPlay.addEventListener("click", () => setTab("play"));

    // -----------------------------
    // Theme
    // -----------------------------
    const THEMES = ["blue","slate","forest"];
    function setTheme(t){
      document.body.setAttribute("data-theme", THEMES.includes(t) ? t : "blue");
    }
    function cycleTheme(){
      const cur = document.body.getAttribute("data-theme") || "blue";
      const idx = THEMES.indexOf(cur);
      setTheme(THEMES[(idx+1) % THEMES.length]);
    }
    el.btnTheme.addEventListener("click", cycleTheme);

    // -----------------------------
    // Fullscreen
    // -----------------------------
    el.btnFull.addEventListener("click", async () => {
      try{
        if (!document.fullscreenElement) await document.documentElement.requestFullscreen();
        else await document.exitFullscreen();
      }catch{}
    });

    // -----------------------------
    // Base64 helpers
    // -----------------------------
    function bytesToB64(bytes){
      let bin = "";
      const chunk = 0x8000;
      for (let i=0; i<bytes.length; i+=chunk){
        bin += String.fromCharCode(...bytes.subarray(i, i+chunk));
      }
      return btoa(bin);
    }
    function b64ToBytes(b64){
      const bin = atob(b64);
      const out = new Uint8Array(bin.length);
      for (let i=0; i<bin.length; i++) out[i] = bin.charCodeAt(i);
      return out;
    }

    // -----------------------------
    // Crypto (PBKDF2 + AES-GCM)
    // -----------------------------
    const enc = new TextEncoder();
    const dec = new TextDecoder();
    const KDF_ITER = 200000;

    async function deriveKey(password, salt, iter){
      const keyMat = await crypto.subtle.importKey("raw", enc.encode(password), "PBKDF2", false, ["deriveKey"]);
      return crypto.subtle.deriveKey(
        {name:"PBKDF2", hash:"SHA-256", salt, iterations: iter},
        keyMat,
        {name:"AES-GCM", length:256},
        false,
        ["encrypt","decrypt"]
      );
    }

    async function encryptToJpuz(password, payloadObj){
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const key = await deriveKey(password, salt, KDF_ITER);

      const pt = enc.encode(JSON.stringify(payloadObj));
      const ctBuf = await crypto.subtle.encrypt({name:"AES-GCM", iv}, key, pt);

      return {
        v: 1,
        kdf: "PBKDF2",
        iter: KDF_ITER,
        salt: bytesToB64(salt),
        alg: "AES-GCM",
        iv: bytesToB64(iv),
        ct: bytesToB64(new Uint8Array(ctBuf))
      };
    }

    async function decryptFromJpuz(password, jpuzObj){
      const req = ["v","kdf","iter","salt","alg","iv","ct"];
      for (const k of req) if (!(k in jpuzObj)) throw new Error("Falta campo en .jpuz: " + k);
      if (jpuzObj.v !== 1) throw new Error("Versión .jpuz no soportada.");
      if (jpuzObj.kdf !== "PBKDF2") throw new Error("KDF no soportada.");
      if (jpuzObj.alg !== "AES-GCM") throw new Error("Algoritmo no soportado.");

      const salt = b64ToBytes(jpuzObj.salt);
      const iv = b64ToBytes(jpuzObj.iv);
      const ct = b64ToBytes(jpuzObj.ct);
      const iter = Number(jpuzObj.iter);

      const key = await deriveKey(password, salt, iter);

      let ptBuf;
      try{
        ptBuf = await crypto.subtle.decrypt({name:"AES-GCM", iv}, key, ct);
      }catch{
        throw new Error("Descifrado fallido: contraseña incorrecta o archivo corrupto.");
      }
      const json = dec.decode(ptBuf);
      return JSON.parse(json);
    }

    // -----------------------------
    // Image processing (resize + crop ratio puzzle + JPEG)
    // -----------------------------
    function clamp(n,a,b){ return Math.min(b, Math.max(a, n)); }

    async function compressImageToJpegBase64(file, {maxDim, quality, targetAspect}){
      const bmp = await createImageBitmap(file);

      // resize
      const inW = bmp.width, inH = bmp.height;
      const scale = Math.min(1, maxDim / Math.max(inW, inH));
      const rW = Math.max(1, Math.round(inW * scale));
      const rH = Math.max(1, Math.round(inH * scale));

      const tmp = document.createElement("canvas");
      tmp.width = rW; tmp.height = rH;
      const tctx = tmp.getContext("2d", {alpha:false, desynchronized:true});
      tctx.imageSmoothingEnabled = true;
      tctx.imageSmoothingQuality = "high";
      tctx.drawImage(bmp, 0, 0, rW, rH);

      // center crop to targetAspect (so puzzle fills nicely)
      let sx=0, sy=0, sw=rW, sh=rH;
      if (targetAspect && isFinite(targetAspect) && targetAspect > 0){
        const cur = rW / rH;
        if (cur > targetAspect){
          sh = rH;
          sw = Math.round(rH * targetAspect);
          sx = Math.round((rW - sw)/2);
        }else if (cur < targetAspect){
          sw = rW;
          sh = Math.round(rW / targetAspect);
          sy = Math.round((rH - sh)/2);
        }
      }

      const out = document.createElement("canvas");
      out.width = sw; out.height = sh;
      const octx = out.getContext("2d", {alpha:false, desynchronized:true});
      octx.imageSmoothingEnabled = true;
      octx.imageSmoothingQuality = "high";
      octx.drawImage(tmp, sx, sy, sw, sh, 0, 0, sw, sh);

      const blob = await new Promise((resolve, reject) => {
        out.toBlob(b => b ? resolve(b) : reject(new Error("Fallo codificando JPEG.")), "image/jpeg", quality);
      });

      const b64 = await new Promise((resolve, reject) => {
        const r = new FileReader();
        r.onload = () => {
          const s = String(r.result || "");
          const i = s.indexOf(",");
          resolve(i >= 0 ? s.slice(i+1) : s);
        };
        r.onerror = () => reject(new Error("No se pudo leer JPEG."));
        r.readAsDataURL(blob);
      });

      return { mime:"image/jpeg", imgB64:b64, w: sw, h: sh, bytes: blob.size };
    }

    function downloadText(filename, text){
      const blob = new Blob([text], {type:"application/json"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 1500);
    }

    // -----------------------------
    // Robust loader for Konva + Headbreaker
    // -----------------------------
    function loadScript(src){
      return new Promise((resolve, reject) => {
        const s = document.createElement("script");
        s.src = src;
        s.async = false;
        s.onload = () => resolve(src);
        s.onerror = () => reject(new Error("No se pudo cargar: " + src));
        document.head.appendChild(s);
      });
    }

    async function loadFirstWorking(name, urls, testFn){
      let lastErr = null;
      for (const u of urls){
        try{
          await loadScript(u);
          if (testFn()) return u;
          lastErr = new Error(name + " cargó pero no expuso el global esperado: " + u);
        }catch(e){
          lastErr = e;
        }
      }
      throw lastErr || new Error("No se pudo cargar " + name);
    }

    async function loadLibs(){
      setStatus("Cargando librerías (Konva/Headbreaker)…", "warn");

      const konvaURL = await loadFirstWorking(
        "Konva",
        [
          "./vendor/konva.min.js",
          "https://cdnjs.cloudflare.com/ajax/libs/konva/8.4.3/konva.min.js",
          "https://cdn.jsdelivr.net/npm/konva@8.4.3/konva.min.js"
        ],
        () => !!window.Konva
      );

      const hbURL = await loadFirstWorking(
        "Headbreaker",
        [
          "./vendor/headbreaker.js",
          "https://flbulgarelli.github.io/headbreaker/js/headbreaker.js"
        ],
        () => !!window.headbreaker && !!window.headbreaker.Canvas
      );

      return { konvaURL, hbURL };
    }

    // -----------------------------
    // Puzzle runtime
    // -----------------------------
    const game = {
      canvas: null,
      payload: null,
      imgDataUrl: null,
      state: "idle", // idle|playing|paused|timeout|solved|finished
      endAt: 0,
      pausedRemaining: 0,
      tickId: null,
      mystery: false
    };

    function setTimerSeconds(sec){
      const s = Math.max(0, Math.ceil(sec));
      const mm = String(Math.floor(s/60)).padStart(2,"0");
      const ss = String(s%60).padStart(2,"0");
      el.timeText.textContent = `${mm}:${ss}`;
    }
    function stopTimer(){
      if (game.tickId) clearInterval(game.tickId);
      game.tickId = null;
    }
    function remainingSeconds(){
      if (game.state === "paused") return Math.ceil(game.pausedRemaining/1000);
      return Math.ceil((game.endAt - performance.now())/1000);
    }
    function startTimer(seconds){
      stopTimer();
      game.endAt = performance.now() + seconds*1000;
      setTimerSeconds(seconds);
      game.tickId = setInterval(() => {
        if (game.state !== "playing") return;
        const rem = remainingSeconds();
        setTimerSeconds(rem);
        if (rem <= 0) onTimeout();
      }, 200);
    }

    function enableControls(active){
      el.btnPause.disabled = !active;
      el.btnReframe.disabled = !active;
      el.btnBoxTop.disabled = !active || game.mystery;
    }

    function clearBoard(){
      stopTimer();
      game.state = "idle";
      game.payload = null;
      game.imgDataUrl = null;
      game.mystery = false;
      setTimerSeconds(0);

      el.btnRestart.disabled = true;

      try{
        if (game.canvas) game.canvas.clear();
      }catch{}
      game.canvas = null;

      // wipe host
      el.canvasHost.replaceChildren();

      enableControls(false);
      setStatus("Listo. Crea un reto o carga un .jpuz.", "neutral");
    }

    function boardSize(){
      const r = el.board.getBoundingClientRect();
      return { w: Math.floor(r.width), h: Math.floor(r.height) };
    }

    function setTargetFrame(piecesX, piecesY, pieceSize){
      el.targetFrame.style.width = Math.round(piecesX * pieceSize) + "px";
      el.targetFrame.style.height = Math.round(piecesY * pieceSize) + "px";
    }

    function gridMetadata(px, py){
      const out = [];
      for (let row=0; row<py; row++){
        for (let col=0; col<px; col++){
          out.push({ row, col });
        }
      }
      return out;
    }

    function ensureSecureContext(){
      if (!window.isSecureContext || !window.crypto?.subtle){
        showOverlay({
          title: "HTTPS requerido",
          html: `
            <p>Esta app usa <b>WebCrypto</b> (PBKDF2 + AES-GCM). Eso requiere <b>HTTPS</b> (GitHub Pages vale).</p>
            <p class="hint">Si abriste el archivo con <code>file://</code>, publícalo en GitHub Pages o usa un servidor local HTTPS.</p>
          `,
          actions: [{label:"Entendido", primary:true, onClick: () => hideOverlay(true)}],
          lock: false
        });
        throw new Error("Contexto no seguro: se requiere HTTPS para WebCrypto.");
      }
    }

    async function loadImage(url){
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = () => reject(new Error("No se pudo cargar la imagen (data URL)."));
        img.src = url;
      });
    }

    async function buildPuzzle(payload){
      const hb = window.headbreaker;
      if (!hb?.Canvas) throw new Error("Headbreaker no está disponible.");

      // clean previous
      try{ if (game.canvas) game.canvas.clear(); }catch{}
      game.canvas = null;
      el.canvasHost.replaceChildren();

      // validate payload
      const piecesX = clamp(Number(payload.piecesX), 2, 30);
      const piecesY = clamp(Number(payload.piecesY), 2, 30);
      const solveSeconds = Math.max(1, Math.floor(Number(payload.solveSeconds)));
      const revealSeconds = Math.max(0, Math.floor(Number(payload.revealSeconds)));
      const mystery = !!payload.mystery;
      const bgTheme = String(payload.bgTheme || "blue");

      setTheme(bgTheme);

      game.payload = { ...payload, piecesX, piecesY, solveSeconds, revealSeconds, mystery, bgTheme };
      game.imgDataUrl = `data:${payload.mime};base64,${payload.img}`;
      game.mystery = mystery;

      // load image
      const img = await loadImage(game.imgDataUrl);

      const { w, h } = boardSize();

      // Make final puzzle smaller than workbench (mesa amplia)
      const frameScale = 0.58;
      const pieceSize = clamp(
        Math.floor(Math.min((w*frameScale)/piecesX, (h*frameScale)/piecesY)),
        22,
        140
      );

      const proximity = clamp(Math.round(pieceSize * 0.16), 10, 30);
      const borderFill = clamp(Math.round(pieceSize * 0.11), 6, 18);
      const strokeWidth = clamp(pieceSize * 0.028, 1.0, 2.6);

      setTargetFrame(piecesX, piecesY, pieceSize);

      const opts = {
        width: w,
        height: h,
        pieceSize,
        proximity,
        borderFill,
        strokeWidth,
        strokeColor: "rgba(0,0,0,.32)",
        lineSoftness: 0.22,
        outline: new hb.outline.Rounded(),
        image: img,
        fixed: true,
        preventOffstageDrag: false,
        maxPiecesCount: {x: piecesX, y: piecesY},
      };

      // Prefer explicit Konva painter if available
      if (hb.painters?.Konva) {
        opts.painter = new hb.painters.Konva();
      }

      const canvas = new hb.Canvas("canvasHost", opts);

      // Scale image to puzzle
      // (como en la doc: adjustImagesToPuzzleWidth/Height)
      if ((img.naturalWidth / img.naturalHeight) >= (piecesX / piecesY)) canvas.adjustImagesToPuzzleHeight();
      else canvas.adjustImagesToPuzzleWidth();

      // Generate puzzle with nicer cuts
      canvas.autogenerate({
        horizontalPiecesCount: piecesX,
        verticalPiecesCount: piecesY,
        insertsGenerator: hb.generators.random,
        metadata: gridMetadata(piecesX, piecesY)
      });

      // IMPORTANT: strict correct connections only (no incorrect snaps)
      canvas.puzzle.attachHorizontalConnectionRequirement((a, b) => {
        return a.metadata.row === b.metadata.row && Math.abs(a.metadata.col - b.metadata.col) === 1;
      });
      canvas.puzzle.attachVerticalConnectionRequirement((a, b) => {
        return a.metadata.col === b.metadata.col && Math.abs(a.metadata.row - b.metadata.row) === 1;
      });

      // lock connected groups
      canvas.puzzle.forceConnectionWhileDragging();

      // solved callback
      canvas.attachSolvedValidator();
      canvas.onValid(() => {
        if (game.state === "playing") onSolved();
      });

      // shuffle into workbench
      canvas.shuffleGrid(0.95);
      canvas.draw();

      game.canvas = canvas;

      // start playing
      game.state = "playing";
      startTimer(solveSeconds);
      enableControls(true);
      el.btnRestart.disabled = false;

      setStatus("En juego…", "good");
      el.btnBoxTop.disabled = mystery; // no box top in mystery
    }

    function onTimeout(){
      if (game.state !== "playing") return;
      game.state = "timeout";
      stopTimer();
      setTimerSeconds(0);
      enableControls(false);
      setStatus("Tiempo agotado.", "bad");

      showOverlay({
        title: "Tiempo agotado",
        html: `
          <p>Se agotó el tiempo. Por requisito, <b>no se muestra la imagen</b>.</p>
          <p class="hint">Puedes reiniciar para intentarlo de nuevo.</p>
        `,
        actions: [
          {label:"Reiniciar", primary:true, onClick: () => { hideOverlay(true); restartSame(); }},
        ],
        lock: true
      });
    }

    function onSolved(){
      game.state = "solved";
      stopTimer();
      setStatus("Resuelto. Revelando…", "good");

      const reveal = Math.max(0, Number(game.payload?.revealSeconds || 0));
      const title = String(game.payload?.title || "Reto completado");

      showOverlay({
        title,
        html: `
          <p>¡Bien! Se muestra la imagen completa durante <b>${reveal}</b> s.</p>
          <img alt="Reveal" src="${game.imgDataUrl}">
          <p class="hint">Privacidad práctica: tras descifrar, se puede capturar pantalla.</p>
        `,
        actions: [],
        lock: true
      });

      setTimeout(() => {
        game.state = "finished";
        setStatus("Fin.", "warn");
        showOverlay({
          title: "Fin",
          html: `<p>Terminó el reveal.</p>`,
          actions: [
            {label:"Jugar de nuevo", primary:true, onClick: () => { hideOverlay(true); restartSame(); }},
            {label:"Cerrar", primary:false, onClick: () => { hideOverlay(true); }},
          ],
          lock: true
        });
      }, reveal * 1000);
    }

    function togglePause(){
      if (game.state === "playing"){
        game.state = "paused";
        game.pausedRemaining = Math.max(0, game.endAt - performance.now());
        setStatus("Pausado.", "warn");
        showOverlay({
          title: "Pausado",
          html: `<p>Temporizador detenido.</p><p class="hint">Pulsa P para reanudar.</p>`,
          actions: [{label:"Reanudar", primary:true, onClick: () => { hideOverlay(true); togglePause(); }}],
          lock: false
        });
      } else if (game.state === "paused"){
        hideOverlay(true);
        game.state = "playing";
        game.endAt = performance.now() + game.pausedRemaining;
        game.pausedRemaining = 0;
        setStatus("En juego…", "good");
      }
    }

    function reframe(){
      try{
        if (!game.canvas) return;
        game.canvas.reframeWithinDimensions();
        game.canvas.redraw();
      }catch{}
    }

    function showBoxTop(){
      if (game.mystery || !game.imgDataUrl) return;
      showOverlay({
        title: "Box top",
        html: `<p class="hint">Ayuda visual (B). No es DRM: se puede capturar pantalla.</p><img alt="Box top" src="${game.imgDataUrl}">`,
        actions: [{label:"Cerrar", primary:true, onClick: () => hideOverlay(true)}],
        lock: false
      });
    }

    async function restartSame(){
      if (!game.payload) return;
      showOverlay({
        title: "Reiniciando…",
        html: `<p><span class="spinner"></span>Preparando puzzle…</p>`,
        actions: [],
        lock: true
      });
      try{
        await buildPuzzle(game.payload);
        hideOverlay(true);
      }catch(e){
        hideOverlay(true);
        showOverlay({
          title: "Error",
          html: `<p>${escapeHtml(String(e?.message || e))}</p>`,
          actions: [{label:"Cerrar", primary:true, onClick: () => hideOverlay(true)}],
          lock: false
        });
      }
    }

    // -----------------------------
    // Keyboard shortcuts
    // -----------------------------
    function isTypingTarget(t){
      const tag = (t && t.tagName) ? t.tagName.toLowerCase() : "";
      return tag === "input" || tag === "textarea" || tag === "select" || (t && t.isContentEditable);
    }

    window.addEventListener("keydown", (e) => {
      if (isTypingTarget(e.target)) return;

      if (e.key === "Escape"){
        hideOverlay(false);
        return;
      }
      if (e.key === "b" || e.key === "B") showBoxTop();
      if (e.key === "p" || e.key === "P") togglePause();
      if (e.key === "t" || e.key === "T") cycleTheme();
      if (e.key === "r" || e.key === "R") reframe();
    });

    // -----------------------------
    // Wire controls
    // -----------------------------
    el.btnPause.addEventListener("click", togglePause);
    el.btnReframe.addEventListener("click", reframe);
    el.btnBoxTop.addEventListener("click", showBoxTop);

    // -----------------------------
    // Create flow
    // -----------------------------
    function refreshCreateInfo(){
      const x = clamp(Number(el.cX.value || 8), 2, 30);
      const y = clamp(Number(el.cY.value || 6), 2, 30);
      el.createInfo.textContent = `${x}×${y} = ${x*y} piezas`;
    }
    el.cX.addEventListener("input", refreshCreateInfo);
    el.cY.addEventListener("input", refreshCreateInfo);
    refreshCreateInfo();

    el.btnGenerate.addEventListener("click", async () => {
      try{
        ensureSecureContext();

        const file = el.cImage.files && el.cImage.files[0];
        if (!file) throw new Error("Selecciona una imagen.");

        const piecesX = clamp(Number(el.cX.value || 8), 2, 30);
        const piecesY = clamp(Number(el.cY.value || 6), 2, 30);
        const solveSeconds = Math.max(1, Math.floor(Number(el.cSolve.value || 300)));
        const revealSeconds = Math.max(0, Math.floor(Number(el.cReveal.value || 6)));
        const mystery = !!el.cMystery.checked;
        const bgTheme = String(el.cTheme.value || "blue");

        const maxDim = clamp(Number(el.cMaxDim.value || 1600), 256, 4096);
        const quality = clamp(Number(el.cQ.value || 0.85), 0.5, 1.0);

        const title = String(el.cTitle.value || "").trim();
        const pwd = String(el.cPwd.value || "");
        if (pwd.length < 8) throw new Error("La contraseña debe tener mínimo 8 caracteres.");

        setTheme(bgTheme);

        showOverlay({
          title: "Procesando…",
          html: `<p><span class="spinner"></span>Comprimiendo y cifrando localmente…</p>`,
          actions: [],
          lock: true
        });

        // crop to puzzle ratio to look nicer (less letterboxing)
        const targetAspect = piecesX / piecesY;
        const comp = await compressImageToJpegBase64(file, {maxDim, quality, targetAspect});

        const payload = {
          v: 1,
          mime: comp.mime,
          img: comp.imgB64,
          piecesX,
          piecesY,
          solveSeconds,
          revealSeconds,
          mystery,
          bgTheme,
          createdAt: new Date().toISOString(),
          title: title || undefined,
          compression: { maxDim, quality }
        };

        const jpuz = await encryptToJpuz(pwd, payload);
        const text = JSON.stringify(jpuz, null, 2);

        downloadText("reto.jpuz", text);

        hideOverlay(true);
        showOverlay({
          title: "Reto generado",
          html: `<p>Se descargó <code>reto.jpuz</code>.</p><p class="hint">Comparte archivo y contraseña por separado.</p>`,
          actions: [{label:"Cerrar", primary:true, onClick: () => hideOverlay(true)}],
          lock: false
        });

        setStatus("Reto creado. Puedes ir a “Jugar” y cargar el .jpuz.", "good");

      }catch(e){
        hideOverlay(true);
        showOverlay({
          title: "Error",
          html: `<p>${escapeHtml(String(e?.message || e))}</p>`,
          actions: [{label:"Cerrar", primary:true, onClick: () => hideOverlay(true)}],
          lock: false
        });
        setStatus("Error.", "bad");
      }
    });

    // -----------------------------
    // Play flow
    // -----------------------------
    el.btnStart.addEventListener("click", async () => {
      try{
        ensureSecureContext();

        const f = el.pFile.files && el.pFile.files[0];
        if (!f) throw new Error("Selecciona un .jpuz.");
        const pwd = String(el.pPwd.value || "");
        if (pwd.length < 8) throw new Error("Contraseña inválida (mínimo 8).");

        showOverlay({
          title: "Descifrando…",
          html: `<p><span class="spinner"></span>Descifrando localmente…</p>`,
          actions: [],
          lock: true
        });

        const text = await f.text();
        let jpuz;
        try{ jpuz = JSON.parse(text); }catch{ throw new Error("El archivo .jpuz no es JSON válido."); }

        const payload = await decryptFromJpuz(pwd, jpuz);

        hideOverlay(true);

        showOverlay({
          title: "Preparando puzzle…",
          html: `<p><span class="spinner"></span>Generando piezas…</p>`,
          actions: [],
          lock: true
        });

        await buildPuzzle(payload);

        hideOverlay(true);

      }catch(e){
        hideOverlay(true);
        showOverlay({
          title: "Error",
          html: `<p>${escapeHtml(String(e?.message || e))}</p>`,
          actions: [{label:"Cerrar", primary:true, onClick: () => hideOverlay(true)}],
          lock: false
        });
        setStatus("Error.", "bad");
      }
    });

    el.btnRestart.addEventListener("click", () => restartSame());

    // -----------------------------
    // Resize
    // -----------------------------
    let resizeT = null;
    window.addEventListener("resize", () => {
      if (!game.canvas) return;
      if (resizeT) clearTimeout(resizeT);
      resizeT = setTimeout(() => {
        try{
          const {w,h} = boardSize();
          game.canvas.resize(w,h);
          game.canvas.redraw();
        }catch{}
      }, 120);
    });

    // -----------------------------
    // Small helpers
    // -----------------------------
    function escapeHtml(s){
      return String(s)
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#039;");
    }

    // -----------------------------
    // Boot: load libs then enable app
    // -----------------------------
    async function boot(){
      try{
        const { konvaURL, hbURL } = await loadLibs();

        setStatus("Listo. Crea un reto o carga un .jpuz.", "neutral");
        el.timeText.textContent = "--:--";

        // Now app is ready
        el.btnGenerate.disabled = false;
        el.btnStart.disabled = false;

        // Explain what got loaded (helpful for debugging)
        // (Shown only if you open overlay manually; not spamming)
        // console.log({konvaURL, hbURL});

      }catch(e){
        setStatus("No se pudieron cargar librerías.", "bad");
        showOverlay({
          title: "No se pudieron cargar librerías (Konva/Headbreaker)",
          html: `
            <p><b>Detalle:</b> ${escapeHtml(String(e?.message || e))}</p>
            <p class="hint">
              Esto suele pasar por: bloqueo de red/CDN, adblock, o falta de archivos vendorizados.
              <br><br>
              <b>Solución más robusta (sin depender de CDNs):</b>
              <br>1) Crea carpeta <code>vendor/</code> en tu repo.
              <br>2) Descarga y guarda:
              <br>&nbsp;&nbsp;• <code>vendor/konva.min.js</code>
              <br>&nbsp;&nbsp;• <code>vendor/headbreaker.js</code>
              <br>3) Recarga la página: el loader de este index los intentará primero.
            </p>
            <p class="hint">
              Nota: para cifrar/descifrar necesitas HTTPS (GitHub Pages).
            </p>
          `,
          actions: [{label:"Cerrar", primary:true, onClick: () => hideOverlay(true)}],
          lock: false
        });
      }
    }

    // Disable actions until libs load
    el.btnGenerate.disabled = true;
    el.btnStart.disabled = true;

    // Controls initial state
    enableControls(false);
    setTimerSeconds(0);

    // Tab initial
    setTab("create");

    // Reframe button action (works only when playing)
    el.btnReframe.addEventListener("click", reframe);

    // Pause button
    el.btnPause.addEventListener("click", togglePause);

    // Box top button
    el.btnBoxTop.addEventListener("click", showBoxTop);

    // Reset to idle on load
    clearBoard();

    // Start
    boot();
  })();
  </script>
</body>
</html>

