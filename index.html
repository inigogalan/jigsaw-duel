<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="color-scheme" content="dark light" />
  <title>JPuz — Crear y Jugar (100% local)</title>
  <style>
    :root{
      --bg0:#07090b;
      --bg1:#0c1216;
      --panel:rgba(12,16,20,.82);
      --line:rgba(255,255,255,.10);
      --line2:rgba(255,255,255,.14);
      --text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.68);
      --muted2:rgba(255,255,255,.54);
      --good:#22c55e;
      --warn:#f59e0b;
      --bad:#ef4444;

      --btn:rgba(255,255,255,.09);
      --btnH:rgba(255,255,255,.13);
      --btnA:rgba(255,255,255,.18);

      --shadow: 0 18px 60px rgba(0,0,0,.42);
      --radius: 14px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      --sans: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      --frame: rgba(255,255,255,.22);

      --feltBase:#0b1b2b;
      --feltGlow:rgba(110,180,255,.10);
    }
    body[data-theme="blue"]{ --feltBase:#0b1b2b; --feltGlow:rgba(110,180,255,.10); }
    body[data-theme="slate"]{ --feltBase:#121416; --feltGlow:rgba(220,220,220,.08); }
    body[data-theme="forest"]{ --feltBase:#0c1b12; --feltGlow:rgba(120,255,170,.10); }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family:var(--sans);
      background:
        radial-gradient(1200px 800px at 12% 10%, rgba(255,255,255,.05), transparent 60%),
        radial-gradient(900px 700px at 90% 5%, rgba(255,255,255,.04), transparent 60%),
        linear-gradient(180deg, var(--bg1), var(--bg0));
      color:var(--text);
      overflow:hidden;
    }

    /* Topbar */
    #topbar{
      height:64px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding:10px 12px;
      background: rgba(10,14,18,.82);
      border-bottom:1px solid var(--line);
      backdrop-filter: blur(10px);
      position:relative;
      z-index:10;
    }
    #brand{
      display:flex; align-items:center; gap:10px;
      min-width: 210px;
    }
    #logo{
      width:34px;height:34px;border-radius:10px;
      background:
        radial-gradient(circle at 30% 30%, rgba(255,255,255,.28), rgba(255,255,255,.10) 40%, rgba(0,0,0,.18) 70%),
        linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.03));
      border:1px solid rgba(255,255,255,.12);
      box-shadow: 0 10px 26px rgba(0,0,0,.30);
    }
    #brandText{ line-height:1.12; }
    #brandText b{ font-size:14px; letter-spacing:.2px; }
    #brandText span{ display:block; font-size:12px; color:var(--muted2); }

    #centerBar{
      flex:1;
      display:flex;
      align-items:center;
      justify-content:center;
      gap:10px;
      min-width:0;
    }
    #statusPill{
      display:flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.07);
      max-width: 60vw;
      min-width: 220px;
    }
    #statusDot{
      width:9px;height:9px;border-radius:99px;
      background: rgba(255,255,255,.50);
      box-shadow: 0 0 0 3px rgba(255,255,255,.06);
      flex:0 0 auto;
    }
    #statusText{
      font-size:13px;
      color:var(--muted);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    #timer{
      font-family:var(--mono);
      font-size:14px;
      padding:7px 10px;
      border-radius:12px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.22);
      min-width:100px;
      text-align:center;
    }

    .btn{
      appearance:none;
      border:1px solid var(--line);
      background: var(--btn);
      color:var(--text);
      padding:8px 10px;
      border-radius:12px;
      cursor:pointer;
      transition: background .15s ease, transform .05s ease, border-color .15s ease;
      display:inline-flex;
      align-items:center;
      gap:8px;
      user-select:none;
      white-space:nowrap;
      font-size:13px;
    }
    .btn:hover{ background: var(--btnH); border-color: var(--line2); }
    .btn:active{ transform: translateY(1px); background: var(--btnA); }
    .btn[disabled]{ opacity:.5; cursor:not-allowed; }
    .k{
      font-family:var(--mono);
      font-size:11px;
      color:var(--muted2);
      border:1px solid var(--line);
      padding:2px 6px;
      border-radius:8px;
      background: rgba(0,0,0,.18);
    }
    .btnPrimary{
      background: rgba(34,197,94,.14);
      border-color: rgba(34,197,94,.28);
    }
    .btnPrimary:hover{ background: rgba(34,197,94,.20); border-color: rgba(34,197,94,.34); }

    #rightControls{
      display:flex; align-items:center; gap:8px;
      min-width: 260px;
      justify-content:flex-end;
    }

    /* Layout */
    #layout{
      height: calc(100% - 64px);
      display:grid;
      grid-template-columns: 360px 1fr;
      min-height:0;
    }
    #panel{
      border-right:1px solid var(--line);
      background: rgba(10,14,18,.62);
      backdrop-filter: blur(10px);
      min-height:0;
      overflow:auto;
      padding:12px;
    }
    .tabs{
      display:flex;
      gap:8px;
      margin-bottom:12px;
    }
    .tab{
      flex:1;
      text-align:center;
      padding:10px;
      border-radius:12px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.06);
      color:var(--muted);
      cursor:pointer;
      user-select:none;
      font-size:13px;
    }
    .tab.active{
      color:var(--text);
      background: rgba(255,255,255,.12);
      border-color: var(--line2);
    }

    .card{
      background: rgba(255,255,255,.04);
      border:1px solid var(--line);
      border-radius: var(--radius);
      padding:12px;
      box-shadow: 0 14px 46px rgba(0,0,0,.22);
      margin-bottom:12px;
    }
    .card h3{
      margin:0 0 10px 0;
      font-size:13px;
      letter-spacing:.2px;
    }
    label{
      display:flex;
      flex-direction:column;
      gap:6px;
      font-size:12px;
      color:var(--muted);
      margin-bottom:10px;
    }
    input[type="text"], input[type="password"], input[type="number"], select, input[type="file"]{
      width:100%;
      padding:10px 10px;
      border-radius:12px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.22);
      color:var(--text);
      outline:none;
    }
    input[type="file"]{
      border-style:dashed;
      background: rgba(0,0,0,.14);
    }
    .grid2{ display:grid; grid-template-columns:1fr 1fr; gap:10px; }
    .row{ display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap; }
    .hint{
      font-size:12px;
      color:var(--muted2);
      line-height:1.35;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:7px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.18);
      font-family:var(--mono);
      font-size:11px;
      color:var(--muted2);
    }

    /* Board */
    #board{
      position:relative;
      overflow:hidden;
      background:
        radial-gradient(1100px 800px at 16% 22%, var(--feltGlow), transparent 55%),
        radial-gradient(900px 700px at 84% 20%, rgba(255,255,255,.05), transparent 60%),
        linear-gradient(180deg, rgba(255,255,255,.06), rgba(0,0,0,.10)),
        linear-gradient(180deg, var(--feltBase), rgba(0,0,0,.35));
    }
    #canvasHost{
      position:absolute;
      inset:0;
      /* important para móvil: evita scroll/zoom del navegador al arrastrar */
      touch-action: none;
      outline:none;
    }
    #targetFrame{
      position:absolute;
      left:50%;
      top:50%;
      transform: translate(-50%,-50%);
      border-radius: 16px;
      border: 2px dashed var(--frame);
      background: rgba(0,0,0,.04);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.25);
      pointer-events:none;
    }
    #targetFrame::after{
      content:"Marco guía";
      position:absolute;
      left:12px;
      top:10px;
      font-size:11px;
      color: rgba(255,255,255,.58);
      background: rgba(0,0,0,.22);
      border:1px solid rgba(255,255,255,.12);
      padding:5px 8px;
      border-radius:999px;
    }

    /* Overlay */
    #overlay{
      position:absolute;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      z-index:20;
      padding:18px;
    }
    #overlay.active{ display:flex; }
    #overlay.lock .backdrop{ background: rgba(0,0,0,.92); }
    .backdrop{
      position:absolute; inset:0;
      background: rgba(0,0,0,.70);
      backdrop-filter: blur(10px);
    }
    .modal{
      position:relative;
      width:min(760px, 100%);
      max-height:min(86vh, 860px);
      overflow:auto;
      border-radius: 18px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(12,16,20,.96);
      box-shadow: var(--shadow);
      padding:14px;
    }
    .modal h2{
      margin:0 0 8px 0;
      font-size:16px;
      letter-spacing:.2px;
    }
    .modal .content{
      color:var(--muted);
      font-size:13px;
      line-height:1.45;
    }
    .modal .actions{
      display:flex;
      justify-content:flex-end;
      gap:10px;
      margin-top:12px;
      flex-wrap:wrap;
    }
    .modal img{
      width:100%;
      max-height:58vh;
      object-fit:contain;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
      display:block;
      margin-top:10px;
    }
    .spinner{
      width:14px;height:14px;
      border-radius:99px;
      border:2px solid rgba(255,255,255,.18);
      border-top-color: rgba(255,255,255,.85);
      display:inline-block;
      animation: spin .8s linear infinite;
      vertical-align:-2px;
      margin-right:8px;
    }
    @keyframes spin{ to{ transform:rotate(360deg);} }

    /* Responsive */
    @media (max-width: 920px){
      body{ overflow:auto; }
      #layout{
        grid-template-columns: 1fr;
        grid-template-rows: auto 1fr;
        height:auto;
      }
      #panel{
        border-right:none;
        border-bottom:1px solid var(--line);
      }
      #rightControls{ min-width:0; }
      #brand{ min-width:0; }
      #statusPill{ max-width: 50vw; min-width: 180px; }
    }
  </style>
</head>

<body data-theme="blue">
  <header id="topbar" aria-label="Controles">
    <div id="brand">
      <div id="logo" aria-hidden="true"></div>
      <div id="brandText">
        <b>JPuz</b>
        <span>Crear · compartir .jpuz · jugar (local)</span>
      </div>
    </div>

    <div id="centerBar">
      <div id="statusPill" aria-live="polite" aria-atomic="true">
        <span id="statusDot" aria-hidden="true"></span>
        <span id="statusText">Cargando librerías…</span>
      </div>
      <div id="timer" title="Tiempo restante (mm:ss)">
        <span id="timeText">--:--</span>
      </div>
    </div>

    <div id="rightControls">
      <button class="btn" id="btnBoxTop" title="Box top (B)" disabled>Box top <span class="k">B</span></button>
      <button class="btn" id="btnPause" title="Pausar/Reanudar (P)" disabled>Pausa <span class="k">P</span></button>
      <button class="btn" id="btnTheme" title="Cambiar tema (T)">Tema <span class="k">T</span></button>
      <button class="btn" id="btnReframe" title="Reencuadrar (R)" disabled>Reencuadrar <span class="k">R</span></button>
      <button class="btn" id="btnFull" title="Pantalla completa">⛶</button>
    </div>
  </header>

  <div id="layout">
    <aside id="panel">
      <div class="tabs" role="tablist" aria-label="Modo">
        <div class="tab active" id="tabCreate" role="tab" aria-selected="true" tabindex="0">Crear</div>
        <div class="tab" id="tabPlay" role="tab" aria-selected="false" tabindex="0">Jugar</div>
      </div>

      <!-- CREATE -->
      <section id="paneCreate">
        <div class="card">
          <h3>Crear reto</h3>
          <label>Imagen (local)
            <input id="cImage" type="file" accept="image/*" />
          </label>

          <div class="grid2">
            <label>Piezas X (2–30)
              <input id="cX" type="number" min="2" max="30" value="8" />
            </label>
            <label>Piezas Y (2–30)
              <input id="cY" type="number" min="2" max="30" value="6" />
            </label>
          </div>

          <div class="grid2">
            <label>Tiempo límite (s)
              <input id="cSolve" type="number" min="10" value="300" />
            </label>
            <label>Reveal al completar (s)
              <input id="cReveal" type="number" min="0" value="6" />
            </label>
          </div>

          <div class="grid2">
            <label>Tema inicial
              <select id="cTheme">
                <option value="blue">Azul</option>
                <option value="slate">Pizarra</option>
                <option value="forest">Bosque</option>
              </select>
            </label>
            <label style="gap:8px;">
              Mystery mode
              <div class="row" style="justify-content:flex-start;">
                <input id="cMystery" type="checkbox" />
                <span class="hint">Desactiva box top</span>
              </div>
            </label>
          </div>

          <div class="grid2">
            <label>Max dimensión (px)
              <input id="cMaxDim" type="number" min="256" max="4096" value="1600" />
            </label>
            <label>Calidad JPEG (0.5–1.0)
              <input id="cQ" type="number" min="0.5" max="1" step="0.05" value="0.85" />
            </label>
          </div>

          <label>Título (opcional)
            <input id="cTitle" type="text" placeholder="Ej: Atardecer" />
          </label>

          <label>Contraseña (mín. 8)
            <input id="cPwd" type="password" minlength="8" placeholder="********" />
          </label>

          <div class="row">
            <button class="btn btnPrimary" id="btnGenerate" type="button">Generar .jpuz</button>
            <span class="pill" id="createInfo">—</span>
          </div>

          <p class="hint" style="margin:10px 0 0 0;">
            Privacidad práctica: tras descifrar, alguien puede capturar pantalla. No es evitable al 100%.
          </p>
        </div>
      </section>

      <!-- PLAY -->
      <section id="panePlay" style="display:none;">
        <div class="card">
          <h3>Jugar reto</h3>
          <label>Archivo .jpuz
            <input id="pFile" type="file" accept=".jpuz,application/json" />
          </label>
          <label>Contraseña
            <input id="pPwd" type="password" minlength="8" placeholder="********" />
          </label>
          <div class="row">
            <button class="btn btnPrimary" id="btnStart" type="button">Descifrar y jugar</button>
            <button class="btn" id="btnRestart" type="button" disabled>Reiniciar</button>
          </div>

          <p class="hint" style="margin:10px 0 0 0;">
            Atajos: <b>B</b> box top · <b>P</b> pausa · <b>T</b> tema · <b>R</b> reencuadrar · <b>Esc</b> cerrar overlays
          </p>
        </div>

        <div class="card">
          <h3>Diagnóstico rápido (si no cargan librerías)</h3>
          <p class="hint" style="margin:0;">
            Si tu red bloquea CDNs, añade en tu repo:
            <br>• <code>vendor/konva.min.js</code>
            <br>• <code>vendor/headbreaker.js</code>
            <br>El loader de esta página los intentará usar automáticamente.
          </p>
        </div>
      </section>
    </aside>

    <main id="board" aria-label="Mesa de trabajo">
      <div id="canvasHost" tabindex="0" aria-label="Puzzle"></div>
      <div id="targetFrame" aria-hidden="true"></div>

      <div id="overlay" role="dialog" aria-modal="true" aria-live="assertive">
        <div class="backdrop"></div>
        <div class="modal">
          <h2 id="ovTitle">—</h2>
          <div class="content" id="ovBody"></div>
          <div class="actions" id="ovActions"></div>
        </div>
      </div>
    </main>
  </div>

  <script>
  (() => {
    "use strict";

    // -----------------------------
    // DOM
    // -----------------------------
    const $ = (s, el=document) => el.querySelector(s);

    const el = {
      statusDot: $("#statusDot"),
      statusText: $("#statusText"),
      timeText: $("#timeText"),

      tabCreate: $("#tabCreate"),
      tabPlay: $("#tabPlay"),
      paneCreate: $("#paneCreate"),
      panePlay: $("#panePlay"),

      cImage: $("#cImage"),
      cX: $("#cX"),
      cY: $("#cY"),
      cSolve: $("#cSolve"),
      cReveal: $("#cReveal"),
      cTheme: $("#cTheme"),
      cMystery: $("#cMystery"),
      cMaxDim: $("#cMaxDim"),
      cQ: $("#cQ"),
      cTitle: $("#cTitle"),
      cPwd: $("#cPwd"),
      btnGenerate: $("#btnGenerate"),
      createInfo: $("#createInfo"),

      pFile: $("#pFile"),
      pPwd: $("#pPwd"),
      btnStart: $("#btnStart"),
      btnRestart: $("#btnRestart"),

      btnBoxTop: $("#btnBoxTop"),
      btnPause: $("#btnPause"),
      btnTheme: $("#btnTheme"),
      btnReframe: $("#btnReframe"),
      btnFull: $("#btnFull"),

      board: $("#board"),
      canvasHost: $("#canvasHost"),
      targetFrame: $("#targetFrame"),

      overlay: $("#overlay"),
      ovTitle: $("#ovTitle"),
      ovBody: $("#ovBody"),
      ovActions: $("#ovActions"),
    };

    // -----------------------------
    // UI helpers
    // -----------------------------
    function setStatus(text, kind="neutral"){
      el.statusText.textContent = text;
      const c = (kind==="good") ? "rgba(34,197,94,.95)"
              : (kind==="warn") ? "rgba(245,158,11,.95)"
              : (kind==="bad")  ? "rgba(239,68,68,.95)"
              : "rgba(255,255,255,.55)";
      el.statusDot.style.background = c;
      el.statusDot.style.boxShadow = (kind==="good") ? "0 0 0 3px rgba(34,197,94,.14)"
                                : (kind==="warn") ? "0 0 0 3px rgba(245,158,11,.14)"
                                : (kind==="bad")  ? "0 0 0 3px rgba(239,68,68,.14)"
                                : "0 0 0 3px rgba(255,255,255,.06)";
    }

    function showOverlay({title, html, actions=[], lock=false}){
      el.ovTitle.textContent = title || "—";
      el.ovBody.innerHTML = html || "";
      el.ovActions.innerHTML = "";
      el.overlay.classList.toggle("lock", !!lock);
      el.overlay.classList.add("active");

      for (const a of actions){
        const b = document.createElement("button");
        b.className = "btn " + (a.primary ? "btnPrimary" : "");
        b.textContent = a.label;
        b.addEventListener("click", () => a.onClick && a.onClick());
        el.ovActions.appendChild(b);
      }
    }
    function hideOverlay(force=false){
      if (!force && el.overlay.classList.contains("lock")) return;
      el.overlay.classList.remove("active","lock");
      el.ovTitle.textContent = "—";
      el.ovBody.innerHTML = "";
      el.ovActions.innerHTML = "";
    }
    el.overlay.addEventListener("click", (e) => {
      if (el.overlay.classList.contains("lock")) return;
      if (e.target === el.overlay || e.target.classList.contains("backdrop")) hideOverlay(false);
    });

    // -----------------------------
    // Tabs
    // -----------------------------
    function setTab(which){
      const create = which === "create";
      el.tabCreate.classList.toggle("active", create);
      el.tabPlay.classList.toggle("active", !create);
      el.paneCreate.style.display = create ? "" : "none";
      el.panePlay.style.display = create ? "none" : "";
      el.tabCreate.setAttribute("aria-selected", String(create));
      el.tabPlay.setAttribute("aria-selected", String(!create));
    }
    el.tabCreate.addEventListener("click", () => setTab("create"));
    el.tabPlay.addEventListener("click", () => setTab("play"));

    // -----------------------------
    // Theme
    // -----------------------------
    const THEMES = ["blue","slate","forest"];
    function setTheme(t){
      document.body.setAttribute("data-theme", THEMES.includes(t) ? t : "blue");
    }
    function cycleTheme(){
      const cur = document.body.getAttribute("data-theme") || "blue";
      const idx = THEMES.indexOf(cur);
      setTheme(THEMES[(idx+1) % THEMES.length]);
    }
    el.btnTheme.addEventListener("click", cycleTheme);

    // -----------------------------
    // Fullscreen
    // -----------------------------
    el.btnFull.addEventListener("click", async () => {
      try{
        if (!document.fullscreenElement) await document.documentElement.requestFullscreen();
        else await document.exitFullscreen();
      }catch{}
    });

    // -----------------------------
    // Base64 helpers
    // -----------------------------
    function bytesToB64(bytes){
      let bin = "";
      const chunk = 0x8000;<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>JPUZ — Crear y Jugar (100% local)</title>
  <style>
    :root{
      --bg0:#0b1220; --bg1:#0f1a2e;
      --card: rgba(255,255,255,.06);
      --text:#eaf0ff;
      --muted: rgba(234,240,255,.75);
      --muted2: rgba(234,240,255,.55);
      --line: rgba(255,255,255,.12);
      --accent:#7dd3fc; --accent2:#a78bfa;
      --danger:#fb7185; --ok:#34d399; --warn:#fbbf24;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 16px;
      --btn: rgba(255,255,255,.10);
      --btnh: rgba(255,255,255,.16);
      --btnp: rgba(255,255,255,.22);
      --focus: 0 0 0 3px rgba(125,211,252,.28);
    }

    body{
      margin:0; color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background:
        radial-gradient(1200px 700px at 20% 10%, rgba(125,211,252,.12), transparent 60%),
        radial-gradient(900px 700px at 85% 25%, rgba(167,139,250,.10), transparent 55%),
        radial-gradient(1200px 900px at 45% 100%, rgba(52,211,153,.08), transparent 60%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      height:100vh;
      overflow:hidden;
    }

    body.theme-blue{ --bg0:#081427; --bg1:#0b1c39; --accent:#60a5fa; --accent2:#22d3ee; }
    body.theme-chalk{ --bg0:#0b0f14; --bg1:#0f1720; --accent:#a3e635; --accent2:#fbbf24; }
    body.theme-forest{ --bg0:#071412; --bg1:#0a1b16; --accent:#34d399; --accent2:#22c55e; }

    .app{ display:flex; flex-direction:column; height:100vh; }

    header{
      display:flex; align-items:center; justify-content:space-between;
      padding:14px 16px;
      border-bottom:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      backdrop-filter: blur(10px);
    }
    .brand{ display:flex; gap:12px; align-items:center; }
    .logo{
      width:36px; height:36px; border-radius:12px;
      background: conic-gradient(from 210deg, var(--accent), var(--accent2), rgba(255,255,255,.10));
      box-shadow: var(--shadow);
    }
    .brand h1{ margin:0; font-size:14px; letter-spacing:.4px; }
    .brand .sub{ display:block; margin-top:2px; font-size:12px; color:var(--muted2); }

    .tabs{
      display:flex; gap:8px;
      background: rgba(255,255,255,.06);
      border:1px solid var(--line);
      padding:4px; border-radius:999px;
    }
    .tab{
      appearance:none; border:0; background:transparent;
      color:var(--muted);
      padding:8px 12px; border-radius:999px;
      cursor:pointer; font-weight:600; font-size:13px;
    }
    .tab[aria-selected="true"]{ background: rgba(255,255,255,.12); color:var(--text); }

    .main{ display:flex; gap:12px; padding:12px; flex:1; min-height:0; }

    .panel{
      width:380px; max-width:42vw; min-width:320px;
      background: var(--card);
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:auto;
    }
    .panel-inner{ padding:14px; }
    .panel h2{ margin:0 0 8px; font-size:14px; letter-spacing:.3px; }
    .hint{ font-size:12px; color:var(--muted2); line-height:1.35; }
    .hr{ height:1px; background:var(--line); margin:12px 0; }

    .grid{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    label{ display:block; font-size:12px; color:var(--muted); margin:0 0 6px; }
    input[type="text"], input[type="password"], input[type="number"], select{
      width:100%; padding:10px 10px;
      border-radius:12px;
      border:1px solid var(--line);
      background: rgba(10,16,28,.55);
      color:var(--text);
      outline:none;
      box-sizing:border-box;
    }
    input:focus, select:focus{ box-shadow: var(--focus); border-color: rgba(125,211,252,.35); }
    input[type="file"]{ width:100%; color:var(--muted); }

    .check{
      display:flex; gap:10px; align-items:flex-start;
      padding:10px; border-radius:12px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.04);
    }
    .check input{ margin-top:2px; }
    .check b{ font-size:12px; display:block; }
    .check span{ font-size:12px; color:var(--muted2); display:block; margin-top:2px; line-height:1.35; }

    .btns{ display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }
    button.btn{
      appearance:none; border:1px solid var(--line);
      background: var(--btn);
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
      font-weight:700;
      font-size:13px;
      display:inline-flex; align-items:center; justify-content:center;
      gap:8px;
      user-select:none;
    }
    button.btn:hover{ background: var(--btnh); }
    button.btn:active{ background: var(--btnp); transform: translateY(1px); }
    button.btn:disabled{ opacity:.5; cursor:not-allowed; }
    .btn.primary{ border-color: rgba(125,211,252,.35); }

    .pill{
      display:inline-flex; padding:4px 8px; border-radius:999px;
      border:1px solid var(--line); background: rgba(255,255,255,.06);
      font-size:12px; color:var(--muted);
      margin-left:8px;
    }

    .stage{
      flex:1; min-width:0;
      border-radius: var(--radius);
      border:1px solid var(--line);
      background: rgba(255,255,255,.04);
      box-shadow: var(--shadow);
      display:flex; flex-direction:column;
      overflow:hidden; position:relative;
    }

    .playerbar{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      padding:10px 12px;
      border-bottom:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      backdrop-filter: blur(10px);
    }

    .status{ display:flex; gap:10px; align-items:center; min-width:0; }
    .status .dot{
      width:10px; height:10px; border-radius:99px; background: var(--accent);
      box-shadow: 0 0 0 3px rgba(125,211,252,.12);
      flex:0 0 auto;
    }
    .status .txt{
      font-weight:800; font-size:13px;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    .status .subtxt{
      display:block; font-weight:600; font-size:12px; color:var(--muted2);
      margin-top:1px;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }

    .timer{
      font-variant-numeric: tabular-nums;
      font-weight:900; letter-spacing:.5px;
      background: rgba(255,255,255,.07);
      border:1px solid var(--line);
      padding:8px 10px;
      border-radius:12px;
      min-width:110px; text-align:center;
    }

    .controls{ display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end; }
    .iconbtn{
      appearance:none;
      border:1px solid var(--line);
      background: rgba(255,255,255,.08);
      color:var(--text);
      padding:8px 10px;
      border-radius:12px;
      cursor:pointer;
      font-weight:800; font-size:12px;
      display:inline-flex; align-items:center; justify-content:center;
      user-select:none;
      white-space:nowrap;
    }
    .iconbtn:hover{ background: rgba(255,255,255,.12); }
    .iconbtn:active{ transform: translateY(1px); }
    .iconbtn:disabled{ opacity:.5; cursor:not-allowed; }

    .canvasWrap{ position:relative; flex:1; min-height:0; touch-action:none; }
    #puzzleCanvas{ width:100%; height:100%; }
    .hudNote{
      position:absolute; left:12px; bottom:12px;
      background: rgba(0,0,0,.25);
      border:1px solid rgba(255,255,255,.12);
      padding:8px 10px;
      border-radius:12px;
      font-size:12px; color:var(--muted);
      backdrop-filter: blur(8px);
      max-width:min(520px, 92%);
      pointer-events:none;
    }

    .overlay{
      position:fixed; inset:0;
      display:none;
      align-items:center; justify-content:center;
      background: rgba(0,0,0,.55);
      backdrop-filter: blur(10px);
      z-index:9999;
      padding:18px;
    }
    .overlay[aria-hidden="false"]{ display:flex; }
    .modal{
      width:min(720px, 96vw);
      max-height: min(86vh, 900px);
      overflow:auto;
      border-radius: 18px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(12,18,30,.90);
      box-shadow: 0 30px 80px rgba(0,0,0,.55);
    }
    .modalHead{
      padding:14px 14px 10px;
      border-bottom:1px solid rgba(255,255,255,.10);
      display:flex; align-items:flex-start; justify-content:space-between; gap:10px;
    }
    .modalHead h3{ margin:0; font-size:14px; letter-spacing:.3px; }
    .modalHead .x{
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.08);
      border-radius:12px;
      padding:8px 10px;
      cursor:pointer;
      font-weight:900;
      color:var(--text);
    }
    .modalBody{ padding:14px; }
    .modalBody p, .modalBody li{ color:var(--muted); font-size:13px; line-height:1.45; }
    .modalBody code{
      background: rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.10);
      padding:2px 6px;
      border-radius:8px;
    }
    .modalFoot{
      padding:12px 14px 14px;
      border-top:1px solid rgba(255,255,255,.10);
      display:flex; gap:10px; justify-content:flex-end; flex-wrap:wrap;
    }
    .imgPreview{
      width:100%;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.03);
      margin-top:10px;
    }

    .small{ font-size:12px; color:var(--muted2); }

    @media (max-width: 980px){
      .main{ flex-direction:column; }
      .panel{ width:auto; max-width:none; min-width:0; }
    }
  </style>
</head>
<body class="theme-blue">
  <div class="app">
    <header>
      <div class="brand">
        <div class="logo" aria-hidden="true"></div>
        <div>
          <h1>JPUZ <span class="pill">100% local</span></h1>
          <span class="sub">Crear → descargar <b>.jpuz</b> → compartir + contraseña → Jugar</span>
        </div>
      </div>

      <div class="tabs" role="tablist" aria-label="Modo">
        <button class="tab" id="tabCreate" role="tab" aria-selected="true">Crear</button>
        <button class="tab" id="tabPlay" role="tab" aria-selected="false">Jugar</button>
      </div>
    </header>

    <div class="main">
      <aside class="panel" id="panelCreate" role="tabpanel" aria-labelledby="tabCreate">
        <div class="panel-inner">
          <h2>Crear reto (.jpuz)</h2>
          <div class="hint">
            Todo ocurre en tu navegador: se comprime la imagen, se cifra (PBKDF2 + AES-GCM) y se descarga un archivo <b>.jpuz</b>.
            <br><br>
            <b>Privacidad práctica:</b> cuando alguien descifra y juega, puede hacer captura de pantalla. No es DRM.
          </div>

          <div class="hr"></div>

          <label>Imagen</label>
          <input type="file" id="c_image" accept="image/*" />
          <img id="c_preview" class="imgPreview" alt="Vista previa" style="display:none" />

          <div class="hr"></div>

          <div class="grid">
            <div>
              <label>Piezas X (2–30)</label>
              <input type="number" id="c_px" min="2" max="30" value="8" />
            </div>
            <div>
              <label>Piezas Y (2–30)</label>
              <input type="number" id="c_py" min="2" max="30" value="6" />
            </div>
            <div>
              <label>Tiempo límite (s)</label>
              <input type="number" id="c_solve" min="5" value="300" />
            </div>
            <div>
              <label>Reveal al completar (s)</label>
              <input type="number" id="c_reveal" min="0" value="6" />
            </div>
          </div>

          <div class="hr"></div>

          <div class="grid">
            <div>
              <label>Tema inicial</label>
              <select id="c_theme">
                <option value="blue">Azul</option>
                <option value="chalk">Pizarra</option>
                <option value="forest">Bosque</option>
              </select>
            </div>
            <div>
              <label>Título (opcional)</label>
              <input type="text" id="c_title" placeholder="Ej: Atardecer" />
            </div>
          </div>

          <div class="hr"></div>

          <div class="check">
            <input type="checkbox" id="c_mystery" />
            <div>
              <b>Mystery mode</b>
              <span>Si está activo, no existe “box top” (no se puede ver la imagen completa durante el juego).</span>
            </div>
          </div>

          <div style="height:10px"></div>

          <div class="check">
            <input type="checkbox" id="c_allowEdgeOnly" checked />
            <div>
              <b>Permitir “Solo bordes”</b>
              <span>El jugador podrá ocultar/mostrar piezas interiores (útil para puzzles grandes).</span>
            </div>
          </div>

          <div class="hr"></div>

          <h2>Compresión</h2>
          <div class="grid">
            <div>
              <label>Max dimensión (px)</label>
              <input type="number" id="c_maxdim" min="256" max="4096" value="1600" />
              <div class="small">Se redimensiona manteniendo proporción.</div>
            </div>
            <div>
              <label>Calidad JPEG (0.5–1.0)</label>
              <input type="number" id="c_quality" min="0.5" max="1.0" step="0.05" value="0.85" />
              <div class="small">Más calidad = más peso.</div>
            </div>
          </div>

          <div class="hr"></div>

          <label>Contraseña (mín. 8 caracteres)</label>
          <input type="password" id="c_pass" minlength="8" placeholder="mínimo 8 caracteres" />

          <div class="btns">
            <button class="btn primary" id="c_generate">Generar y descargar .jpuz</button>
            <button class="btn" id="c_help">Ayuda / atajos</button>
          </div>

          <div class="hr"></div>
          <div class="small">
            Requiere <b>HTTPS</b> (GitHub Pages) porque WebCrypto lo exige.
            <br>
            Estado: <span id="secureBadge">…</span>
          </div>
        </div>
      </aside>

      <aside class="panel" id="panelPlay" role="tabpanel" aria-labelledby="tabPlay" style="display:none">
        <div class="panel-inner">
          <h2>Jugar reto</h2>
          <div class="hint">
            Carga un archivo <b>.jpuz</b> y escribe la contraseña. Se descifra en tu navegador y se inicia el puzzle.
          </div>

          <div class="hr"></div>

          <label>Archivo .jpuz</label>
          <input type="file" id="p_file" accept=".jpuz,application/json" />

          <div class="hr"></div>

          <label>Contraseña</label>
          <input type="password" id="p_pass" minlength="8" placeholder="contraseña del creador" />

          <div class="btns">
            <button class="btn primary" id="p_start">Descifrar e iniciar</button>
            <button class="btn" id="p_help">Ayuda / atajos</button>
          </div>

          <div class="hr"></div>
          <div class="small" id="p_info">Sin reto cargado.</div>
        </div>
      </aside>

      <section class="stage" aria-label="Zona de juego">
        <div class="playerbar">
          <div class="status" aria-live="polite">
            <div class="dot" id="statusDot"></div>
            <div style="min-width:0">
              <div class="txt" id="statusText">Listo</div>
              <div class="subtxt" id="statusSub">Crea o carga un reto para empezar.</div>
            </div>
          </div>

          <div class="timer" id="timerText">--:--</div>

          <div class="controls">
            <button class="iconbtn" id="btnBoxTop" title="Box top (B)">Box top</button>
            <button class="iconbtn" id="btnEdges" title="Solo bordes (E)">Solo bordes</button>
            <button class="iconbtn" id="btnOrganize" title="Organizar piezas (O)">Organizar</button>
            <button class="iconbtn" id="btnZoomOut" title="Zoom -">−</button>
            <button class="iconbtn" id="btnZoomIn" title="Zoom +">+</button>
            <button class="iconbtn" id="btnReframe" title="Reencuadrar (R)">Reencuadrar</button>
            <button class="iconbtn" id="btnPause" title="Pausar/Reanudar (P)">Pausa</button>
            <button class="iconbtn" id="btnTheme" title="Cambiar tema (T)">Tema</button>
            <button class="iconbtn" id="btnFullscreen" title="Pantalla completa (opcional)">Fullscreen</button>
          </div>
        </div>

        <div class="canvasWrap" id="canvasWrap">
          <div id="puzzleCanvas"></div>
          <div class="hudNote">
            Pan: arrastra el fondo · Zoom: botones o rueda · Recuperar: Reencuadrar
            <br><b>B</b> box top, <b>P</b> pausa, <b>T</b> tema, <b>R</b> reencuadrar, <b>O</b> organizar, <b>E</b> solo bordes.
          </div>
        </div>
      </section>
    </div>
  </div>

  <div class="overlay" id="overlay" aria-hidden="true" role="dialog" aria-modal="true">
    <div class="modal">
      <div class="modalHead">
        <h3 id="ovTitle">Mensaje</h3>
        <button class="x" id="ovClose" title="Cerrar (Esc)">✕</button>
      </div>
      <div class="modalBody" id="ovBody"></div>
      <div class="modalFoot" id="ovFoot"></div>
    </div>
  </div>

  <script>
  (() => {
    "use strict";
    const $ = (id) => document.getElementById(id);

    /* Overlay */
    const overlay = $("overlay"), ovTitle = $("ovTitle"), ovBody = $("ovBody"), ovFoot = $("ovFoot"), ovClose = $("ovClose");
    function escapeHtml(s){ return String(s).replace(/[&<>"']/g, c => ({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[c])); }
    function showModal({title, bodyHTML, buttons = []}){
      ovTitle.textContent = title || "Mensaje";
      ovBody.innerHTML = bodyHTML || "";
      ovFoot.innerHTML = "";
      for(const b of buttons){
        const btn = document.createElement("button");
        btn.className = "btn " + (b.kind || "");
        btn.textContent = b.label || "OK";
        btn.onclick = () => b.onClick && b.onClick();
        ovFoot.appendChild(btn);
      }
      overlay.setAttribute("aria-hidden","false");
    }
    function closeModal(){ overlay.setAttribute("aria-hidden","true"); ovBody.innerHTML=""; ovFoot.innerHTML=""; }
    ovClose.onclick = closeModal;
    document.addEventListener("keydown", (e) => { if(e.key==="Escape" && overlay.getAttribute("aria-hidden")==="false"){ e.preventDefault(); closeModal(); } });

    /* Status */
    function setStatus(kind, title, sub){
      const dot = $("statusDot"), t = $("statusText"), s = $("statusSub");
      t.textContent = title || ""; s.textContent = sub || "";
      dot.style.background = kind==="ok" ? "var(--ok)" : kind==="warn" ? "var(--warn)" : kind==="danger" ? "var(--danger)" : "var(--accent)";
    }
    const timerText = $("timerText");
    function fmtTime(ms){
      const sec = Math.ceil(Math.max(0, ms)/1000);
      const m = Math.floor(sec/60), s = sec%60;
      return String(m).padStart(2,"0")+":"+String(s).padStart(2,"0");
    }
    function clamp(n,a,b){ return Math.max(a, Math.min(b,n)); }

    /* Secure badge */
    $("secureBadge").textContent = window.isSecureContext ? "OK (secure context)" : "NO — necesitas HTTPS (GitHub Pages)";

    /* Tabs */
    function setMode(mode){
      const isCreate = mode==="create";
      $("tabCreate").setAttribute("aria-selected", isCreate?"true":"false");
      $("tabPlay").setAttribute("aria-selected", !isCreate?"true":"false");
      $("panelCreate").style.display = isCreate ? "" : "none";
      $("panelPlay").style.display = !isCreate ? "" : "none";
    }
    $("tabCreate").onclick = () => setMode("create");
    $("tabPlay").onclick = () => setMode("play");

    /* Dynamic loader (fix headbreaker not defined) */
    async function loadScript(url){
      return new Promise((resolve, reject) => {
        const s = document.createElement("script");
        s.src = url; s.async = true;
        s.onload = () => resolve(url);
        s.onerror = () => reject(new Error("No se pudo cargar: " + url));
        document.head.appendChild(s);
      });
    }
    async function ensureLib(name, testFn, urls){
      if(testFn()) return;
      let lastErr=null;
      for(const u of urls){
        try{ await loadScript(u); if(testFn()) return; }
        catch(e){ lastErr=e; }
      }
      throw new Error(`${name} no se pudo cargar. ${lastErr?lastErr.message:""}`);
    }
    async function ensureDeps(){
      await ensureLib("Konva", () => !!window.Konva, [
        "https://cdnjs.cloudflare.com/ajax/libs/konva/9.3.0/konva.min.js",
        "https://cdn.jsdelivr.net/npm/konva@9.3.0/konva.min.js"
      ]);
      await ensureLib("Headbreaker", () => !!window.headbreaker, [
        "https://flbulgarelli.github.io/headbreaker/js/headbreaker.js",
        "https://cdn.jsdelivr.net/gh/flbulgarelli/headbreaker@master/js/headbreaker.js"
      ]);
    }

    /* Base64 helpers */
    function bufToB64(buf){
      const bytes = new Uint8Array(buf);
      let bin=""; const chunk=0x8000;
      for(let i=0;i<bytes.length;i+=chunk) bin += String.fromCharCode(...bytes.subarray(i,i+chunk));
      return btoa(bin);
    }
    function b64ToBuf(b64){
      const bin = atob(b64);
      const bytes = new Uint8Array(bin.length);
      for(let i=0;i<bin.length;i++) bytes[i] = bin.charCodeAt(i);
      return bytes.buffer;
    }
    function dataUrlToB64(dataUrl){
      const idx = dataUrl.indexOf("base64,");
      return idx===-1 ? "" : dataUrl.slice(idx+7);
    }
    function blobToDataURL(blob){
      return new Promise((resolve, reject) => {
        const fr = new FileReader();
        fr.onload = () => resolve(fr.result);
        fr.onerror = () => reject(new Error("No se pudo leer blob"));
        fr.readAsDataURL(blob);
      });
    }

    /* Crypto */
    const PBKDF2_ITER = 150000;
    async function deriveKey(password, saltB64, iter){
      const enc = new TextEncoder();
      const baseKey = await crypto.subtle.importKey("raw", enc.encode(password), {name:"PBKDF2"}, false, ["deriveKey"]);
      return crypto.subtle.deriveKey(
        {name:"PBKDF2", salt:new Uint8Array(b64ToBuf(saltB64)), iterations:iter, hash:"SHA-256"},
        baseKey,
        {name:"AES-GCM", length:256},
        false,
        ["encrypt","decrypt"]
      );
    }
    async function encryptPayload(payloadObj, password){
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const iter = PBKDF2_ITER;
      const key = await deriveKey(password, bufToB64(salt.buffer), iter);
      const pt = new TextEncoder().encode(JSON.stringify(payloadObj));
      const ctBuf = await crypto.subtle.encrypt({name:"AES-GCM", iv}, key, pt);
      return { v:1, kdf:"PBKDF2", iter, salt:bufToB64(salt.buffer), alg:"AES-GCM", iv:bufToB64(iv.buffer), ct:bufToB64(ctBuf) };
    }
    async function decryptChallenge(obj, password){
      if(!obj || obj.v!==1) throw new Error("Versión .jpuz no soportada.");
      if(obj.kdf!=="PBKDF2" || obj.alg!=="AES-GCM") throw new Error("KDF/ALG no soportados.");
      const key = await deriveKey(password, obj.salt, obj.iter);
      let ptBuf;
      try{
        ptBuf = await crypto.subtle.decrypt({name:"AES-GCM", iv:new Uint8Array(b64ToBuf(obj.iv))}, key, b64ToBuf(obj.ct));
      }catch{
        throw new Error("Contraseña incorrecta o archivo corrupto.");
      }
      const json = new TextDecoder().decode(ptBuf);
      try{ return JSON.parse(json); }catch{ throw new Error("Payload descifrado no es JSON válido."); }
    }

    /* Image compression */
    async function decodeImageFromFile(file){
      if("createImageBitmap" in window){
        try{
          const bmp = await createImageBitmap(file);
          return {kind:"bitmap", obj:bmp, width:bmp.width, height:bmp.height};
        }catch{}
      }
      const url = URL.createObjectURL(file);
      const img = new Image(); img.decoding="async"; img.src=url;
      await new Promise((res, rej)=>{ img.onload=res; img.onerror=()=>rej(new Error("No se pudo decodificar imagen")); });
      URL.revokeObjectURL(url);
      return {kind:"img", obj:img, width:img.naturalWidth, height:img.naturalHeight};
    }
    async function compressToJpegBase64(file, maxDim, quality){
      const decoded = await decodeImageFromFile(file);
      const w0=decoded.width, h0=decoded.height;
      const scale = Math.min(1, maxDim/Math.max(w0,h0));
      const w=Math.max(1, Math.round(w0*scale));
      const h=Math.max(1, Math.round(h0*scale));
      await new Promise(r=>requestAnimationFrame(r));
      const c=document.createElement("canvas"); c.width=w; c.height=h;
      const ctx=c.getContext("2d",{alpha:false});
      ctx.imageSmoothingEnabled=true; ctx.imageSmoothingQuality="high";
      ctx.drawImage(decoded.obj,0,0,w,h);
      try{ decoded.obj.close && decoded.obj.close(); }catch{}
      const blob = await new Promise(res=>c.toBlob(res,"image/jpeg",quality));
      if(!blob) throw new Error("toBlob devolvió null");
      const dataUrl = await blobToDataURL(blob);
      return { mime:"image/jpeg", imgB64:dataUrlToB64(dataUrl) };
    }

    /* Create UI */
    const c_image=$("c_image"), c_preview=$("c_preview");
    c_image.addEventListener("change", () => {
      const f=c_image.files && c_image.files[0];
      if(!f) return;
      const url=URL.createObjectURL(f);
      c_preview.src=url; c_preview.style.display="";
      c_preview.onload=()=>URL.revokeObjectURL(url);
    });

    function helpModal(){
      showModal({
        title:"Ayuda y atajos",
        bodyHTML: `
          <p><b>Atajos (Jugar):</b></p>
          <ul>
            <li><b>B</b>: box top (si no mystery)</li>
            <li><b>P</b>: pausar/reanudar</li>
            <li><b>T</b>: cambiar tema</li>
            <li><b>R</b>: reencuadrar</li>
            <li><b>O</b>: organizar</li>
            <li><b>E</b>: solo bordes</li>
            <li><b>Esc</b>: cerrar overlays</li>
          </ul>
          <p class="small">Privacidad práctica: no se puede impedir al 100% una captura de pantalla tras descifrar.</p>
        `,
        buttons:[{label:"Cerrar", kind:"primary", onClick: closeModal}]
      });
    }
    $("c_help").onclick = helpModal;
    $("p_help").onclick = helpModal;

    $("c_generate").onclick = async () => {
      try{
        if(!window.isSecureContext) throw new Error("Necesitas HTTPS (GitHub Pages) para WebCrypto.");
        const f=c_image.files && c_image.files[0];
        if(!f) throw new Error("Selecciona una imagen.");
        const piecesX = clamp(parseInt($("c_px").value,10)||0,2,30);
        const piecesY = clamp(parseInt($("c_py").value,10)||0,2,30);
        const solveSeconds = Math.max(5, parseInt($("c_solve").value,10)||0);
        const revealSeconds = Math.max(0, parseInt($("c_reveal").value,10)||0);
        const mystery = !!$("c_mystery").checked;
        const allowEdgeOnly = !!$("c_allowEdgeOnly").checked;
        const bgTheme = $("c_theme").value || "blue";
        const title = ($("c_title").value||"").trim();
        const maxDim = clamp(parseInt($("c_maxdim").value,10)||1600,256,4096);
        const quality = clamp(parseFloat($("c_quality").value)||0.85,0.5,1.0);
        const password = $("c_pass").value||"";
        if(password.length<8) throw new Error("La contraseña debe tener al menos 8 caracteres.");

        showModal({title:"Procesando…", bodyHTML:"<p>Comprimiendo y cifrando (local)…</p>", buttons:[]});

        const comp = await compressToJpegBase64(f, maxDim, quality);
        const payload = {
          mime: comp.mime,
          img: comp.imgB64,
          piecesX, piecesY,
          solveSeconds, revealSeconds,
          mystery,
          bgTheme,
          allowEdgeOnly,
          createdAt: new Date().toISOString(),
          title
        };

        const jpuz = await encryptPayload(payload, password);
        const blob = new Blob([JSON.stringify(jpuz,null,2)], {type:"application/json"});
        const a=document.createElement("a");
        a.href=URL.createObjectURL(blob);
        a.download="reto.jpuz";
        document.body.appendChild(a); a.click(); a.remove();
        setTimeout(()=>URL.revokeObjectURL(a.href), 1500);

        closeModal();
        setStatus("ok","Reto generado","Descargado como reto.jpuz");
      }catch(err){
        showModal({title:"Error", bodyHTML:`<p>${escapeHtml(err.message||String(err))}</p>`, buttons:[{label:"Cerrar", kind:"primary", onClick: closeModal}]});
        setStatus("danger","Error","No se pudo generar el reto.");
      }
    };

    /* Play / Game */
    let lastPayload=null;
    $("p_start").onclick = async () => {
      try{
        if(!window.isSecureContext) throw new Error("Necesitas HTTPS (GitHub Pages) para WebCrypto.");
        const file = $("p_file").files && $("p_file").files[0];
        if(!file) throw new Error("Selecciona un archivo .jpuz.");
        const password = $("p_pass").value||"";
        if(password.length<8) throw new Error("Contraseña demasiado corta.");

        showModal({title:"Descifrando…", bodyHTML:"<p>Descifrando localmente…</p>", buttons:[]});
        const text = await file.text();
        let obj; try{ obj=JSON.parse(text); }catch{ throw new Error("El .jpuz no es JSON válido."); }
        const payload = await decryptChallenge(obj, password);

        lastPayload = payload;
        $("p_info").innerHTML =
          `Reto: <b>${escapeHtml(payload.title||"Sin título")}</b><br>`+
          `Piezas: <b>${payload.piecesX}×${payload.piecesY}</b> · Tiempo: <b>${payload.solveSeconds}s</b>`;

        closeModal();
        await startGame(payload);
      }catch(err){
        showModal({title:"Error", bodyHTML:`<p>${escapeHtml(err.message||String(err))}</p>`, buttons:[{label:"Cerrar", kind:"primary", onClick: closeModal}]});
        setStatus("danger","Error","No se pudo iniciar.");
      }
    };

    /* Theme */
    function setTheme(t){
      document.body.classList.remove("theme-blue","theme-chalk","theme-forest");
      document.body.classList.add(t==="chalk"?"theme-chalk":t==="forest"?"theme-forest":"theme-blue");
    }
    function cycleTheme(){
      const cur = document.body.classList.contains("theme-chalk") ? "chalk" :
                  document.body.classList.contains("theme-forest") ? "forest" : "blue";
      setTheme(cur==="blue"?"chalk":cur==="chalk"?"forest":"blue");
    }
    $("btnTheme").onclick = cycleTheme;

    /* Controls refs */
    const btnBoxTop=$("btnBoxTop"), btnEdges=$("btnEdges"), btnOrganize=$("btnOrganize");
    const btnZoomIn=$("btnZoomIn"), btnZoomOut=$("btnZoomOut"), btnReframe=$("btnReframe");
    const btnPause=$("btnPause"), btnFullscreen=$("btnFullscreen");

    /* Game state */
    let game=null;

    function destroyStage(){
      try{ game && game.stage && game.stage.destroy(); }catch{}
      $("puzzleCanvas").innerHTML="";
    }

    function disableControls(){
      const running = !!(game && game.running);
      btnPause.disabled = !running;
      btnOrganize.disabled = !running;
      btnZoomIn.disabled = !running;
      btnZoomOut.disabled = !running;
      btnReframe.disabled = !running;

      btnTheme.disabled = false;
      btnFullscreen.disabled = false;

      const allowBoxTop = running && game && !game.payload.mystery && !game.timeUp;
      btnBoxTop.disabled = !allowBoxTop;
      btnBoxTop.style.display = (game && game.payload && game.payload.mystery) ? "none" : "";

      const allowEdges = running && game && !!game.payload.allowEdgeOnly && !game.timeUp;
      btnEdges.disabled = !allowEdges;
      btnEdges.style.display = (game && game.payload && game.payload.allowEdgeOnly) ? "" : "none";
    }

    function setInteraction(enabled){
      if(!game || !game.hb) return;
      try{ game.stage.draggable(enabled && !game.timeUp && !game.finished); }catch{}
      for(const p of game.hb.puzzle.pieces){
        const fig = game.hb.getFigure(p);
        if(!fig || !fig.group) continue;
        const visible = fig.group.visible();
        fig.group.draggable(!!(enabled && visible && !game.timeUp && !game.finished && !game.paused));
      }
    }

    /* STRICT connection rules: only real neighbors (prevents wrong snaps) */
    function attachStrictConnectionRules(hb){
      const stepX = hb.puzzle.pieceDiameter.x;
      const stepY = hb.puzzle.pieceDiameter.y;
      const eps = Math.max(1, Math.min(stepX, stepY) * 0.02);

      function isNeighborH(a, b){
        const ta=a.metadata.targetPosition, tb=b.metadata.targetPosition;
        if(!ta || !tb) return false;
        return (Math.abs(ta.y - tb.y) <= eps) && (Math.abs(Math.abs(ta.x - tb.x) - stepX) <= eps);
      }
      function isNeighborV(a, b){
        const ta=a.metadata.targetPosition, tb=b.metadata.targetPosition;
        if(!ta || !tb) return false;
        return (Math.abs(ta.x - tb.x) <= eps) && (Math.abs(Math.abs(ta.y - tb.y) - stepY) <= eps);
      }

      hb.puzzle.attachHorizontalConnectionRequirement((a,b)=>isNeighborH(a,b));
      hb.puzzle.attachVerticalConnectionRequirement((a,b)=>isNeighborV(a,b));
    }

    function annotateGrid(hb, px, py){
      const pieces = hb.puzzle.pieces;
      let minX=Infinity, minY=Infinity;
      for(const p of pieces){
        const tp=p.metadata.targetPosition;
        if(tp){ minX=Math.min(minX,tp.x); minY=Math.min(minY,tp.y); }
      }
      const stepX = hb.puzzle.pieceDiameter.x;
      const stepY = hb.puzzle.pieceDiameter.y;
      for(const p of pieces){
        const tp=p.metadata.targetPosition;
        if(!tp) continue;
        const col = clamp(Math.round((tp.x - minX)/stepX), 0, px-1);
        const row = clamp(Math.round((tp.y - minY)/stepY), 0, py-1);
        p.metadata._grid = {row,col};
        p.metadata._isEdge = (row===0||col===0||row===py-1||col===px-1);
      }
    }

    /* IMPORTANT FIX: scatter ALL pieces BEFORE attachSolvedValidator */
    function scatterAllPiecesIntoTrays(hb, px, py){
      const pieces = hb.puzzle.pieces;
      const rad = hb.puzzle.pieceRadius;
      const step = hb.puzzle.pieceDiameter.x;

      // frame dims (target frame starts at 0,0 in Headbreaker coordinates)
      const frameW = hb.puzzle.pieceDiameter.x * px;
      const frameH = hb.puzzle.pieceDiameter.y * py;

      // trays left/right of frame
      const gap = step * 0.8;
      const trayW = Math.max(frameW * 0.75, step * 8);

      const left =  { x: -trayW - gap, y: 0, w: trayW };
      const right = { x: frameW + gap,  y: 0, w: trayW };

      // split edge vs inner
      const edges = [], inner = [];
      for(const p of pieces){
        (p.metadata._isEdge ? edges : inner).push(p);
      }

      // shuffle lists
      function shuffle(arr){
        for(let i=arr.length-1;i>0;i--){
          const j = (Math.random()*(i+1))|0;
          [arr[i],arr[j]]=[arr[j],arr[i]];
        }
      }
      shuffle(edges); shuffle(inner);

      const cell = step * 1.08;
      function pack(list, tray){
        const cols = Math.max(1, Math.floor(tray.w / cell));
        for(let i=0;i<list.length;i++){
          const p = list[i];
          const cx = tray.x + (i % cols)*cell + rad.x;
          const cy = tray.y + Math.floor(i/cols)*cell + rad.y;
          const jitterX = (Math.random()-0.5)*step*0.18;
          const jitterY = (Math.random()-0.5)*step*0.18;
          const pos = p.centralAnchor.asVector();
          p.push((cx+jitterX)-pos.x, (cy+jitterY)-pos.y);
        }
      }
      pack(edges, left);
      pack(inner, right);

      hb.redraw();
    }

    function setEdgesOnlyMode(enabled){
      if(!game || !game.hb) return;
      if(!game.payload.allowEdgeOnly) return;
      game.edgesOnly = !!enabled;
      const hb = game.hb;
      for(const p of hb.puzzle.pieces){
        const fig = hb.getFigure(p);
        if(!fig || !fig.group) continue;
        const show = (!game.edgesOnly) || !!p.metadata._isEdge;
        fig.group.visible(show);
        fig.group.listening(show);
        fig.group.draggable(show && !game.paused && !game.timeUp && !game.finished);
      }
      hb.redraw();
      btnEdges.textContent = game.edgesOnly ? "Mostrar todo" : "Solo bordes";
    }

    /* Zoom/pan */
    function viewFitAll(){
      if(!game || !game.hb) return;
      const hb = game.hb;
      const wrap = $("canvasWrap");
      const r = wrap.getBoundingClientRect();
      const rad = hb.puzzle.pieceRadius;

      let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
      for(const p of hb.puzzle.pieces){
        const pos = p.centralAnchor.asVector();
        minX=Math.min(minX, pos.x-rad.x);
        minY=Math.min(minY, pos.y-rad.y);
        maxX=Math.max(maxX, pos.x+rad.x);
        maxY=Math.max(maxY, pos.y+rad.y);
      }
      // include target frame (0..frameW/0..frameH)
      const frameW = hb.puzzle.pieceDiameter.x * game.payload.piecesX;
      const frameH = hb.puzzle.pieceDiameter.y * game.payload.piecesY;
      minX=Math.min(minX, 0); minY=Math.min(minY, 0);
      maxX=Math.max(maxX, frameW); maxY=Math.max(maxY, frameH);

      const bw=maxX-minX, bh=maxY-minY;
      const margin=36;
      const scale = clamp(0.92*Math.min((r.width-margin)/bw, (r.height-margin)/bh), 0.18, 2.4);
      game.zoom = scale;
      try{ hb.scale(scale); }catch{ game.stage.scale({x:scale,y:scale}); }

      const x = (r.width - bw*scale)/2 - minX*scale;
      const y = (r.height - bh*scale)/2 - minY*scale;
      game.stage.position({x,y});
      game.stage.batchDraw();
    }

    function setZoom(delta){
      if(!game || !game.hb) return;
      const hb=game.hb;
      const wrap=$("canvasWrap");
      const r=wrap.getBoundingClientRect();
      const old=game.zoom||1;
      const next=clamp(old*delta, 0.18, 2.4);
      const center={x:r.width/2, y:r.height/2};
      const stage=game.stage;
      const stagePos=stage.position();
      const mousePointTo={ x:(center.x-stagePos.x)/old, y:(center.y-stagePos.y)/old };
      game.zoom=next;
      try{ hb.scale(next); }catch{ stage.scale({x:next,y:next}); }
      stage.position({ x:center.x-mousePointTo.x*next, y:center.y-mousePointTo.y*next });
      stage.batchDraw();
    }

    btnZoomIn.onclick = () => setZoom(1.12);
    btnZoomOut.onclick = () => setZoom(1/1.12);
    btnReframe.onclick = () => viewFitAll();

    /* Timer */
    function startTimer(){
      if(!game) return;
      game.remainingMs = (game.payload.solveSeconds|0)*1000;
      game.lastTick = performance.now();
      timerText.textContent = fmtTime(game.remainingMs);
      if(game.timerId) clearInterval(game.timerId);
      game.timerId = setInterval(() => {
        if(!game || !game.running) return;
        if(game.paused || game.solved || game.timeUp || game.finished) return;
        const now=performance.now();
        const dt=now-game.lastTick;
        game.lastTick=now;
        game.remainingMs=Math.max(0, game.remainingMs-dt);
        timerText.textContent=fmtTime(game.remainingMs);
        if(game.remainingMs<=0) onTimeUp();
      }, 200);
    }
    function stopTimer(){ if(game && game.timerId){ clearInterval(game.timerId); game.timerId=null; } }

    function pauseGame(){
      if(!game) return;
      game.paused=true;
      setInteraction(false);
      setStatus("warn","Pausado","Pulsa P o el botón para reanudar.");
      showModal({
        title:"Pausado",
        bodyHTML:"<p>Temporizador detenido.</p>",
        buttons:[
          {label:"Reanudar", kind:"primary", onClick:()=>{ closeModal(); resumeGame(); }},
          {label:"Reencuadrar", onClick:()=>{ closeModal(); viewFitAll(); }}
        ]
      });
      btnPause.textContent="Reanudar";
    }
    function resumeGame(){
      if(!game) return;
      game.paused=false;
      game.lastTick=performance.now();
      setInteraction(true);
      setStatus("info","En juego","Conexiones incorrectas desactivadas.");
      btnPause.textContent="Pausa";
      disableControls();
    }

    function onTimeUp(){
      if(!game || game.timeUp || game.solved) return;
      game.timeUp=true;
      stopTimer();
      setInteraction(false);
      disableControls();
      setStatus("danger","Tiempo agotado","No se muestra la imagen. Puedes reiniciar.");
      showModal({
        title:"Tiempo agotado",
        bodyHTML:"<p>Se terminó el tiempo.</p>",
        buttons:[
          {label:"Reiniciar", kind:"primary", onClick: async ()=>{ closeModal(); await restartGame(); }},
          {label:"Cerrar", onClick: closeModal}
        ]
      });
    }

    async function onSolved(){
      if(!game || game.solved || game.timeUp) return;
      game.solved=true;
      stopTimer();
      setInteraction(false);
      disableControls();
      setStatus("ok","¡Resuelto!","Revelando imagen…");
      const rs = Math.max(0, game.payload.revealSeconds|0);

      showModal({
        title:"¡Completado!",
        bodyHTML: `
          <p>¡Puzzle resuelto!</p>
          <p class="small">Revelando ${rs}s… (después: Fin)</p>
          <img class="imgPreview" alt="Revelado" src="${game.boxTopDataUrl}">
        `,
        buttons:[]
      });

      if(rs>0) await new Promise(r=>setTimeout(r, rs*1000));
      else await new Promise(r=>setTimeout(r, 400));

      closeModal();
      game.finished=true;
      setStatus("ok","Fin","Puedes reiniciar o cargar otro reto.");
      showModal({
        title:"Fin",
        bodyHTML:"<p>Gracias por jugar.</p>",
        buttons:[
          {label:"Reiniciar", kind:"primary", onClick: async ()=>{ closeModal(); await restartGame(); }},
          {label:"Cerrar", onClick: closeModal}
        ]
      });
    }

    async function restartGame(){
      if(!lastPayload) return;
      await startGame(lastPayload);
    }

    /* Box top */
    btnBoxTop.onclick = () => {
      if(!game || !game.running || game.payload.mystery || game.timeUp) return;
      showModal({
        title:"Box top",
        bodyHTML: `
          <p><b>${escapeHtml(game.payload.title||"Imagen")}</b></p>
          <p class="small">Nota: no es posible evitar capturas de pantalla tras descifrar.</p>
          <img class="imgPreview" alt="Box top" src="${game.boxTopDataUrl}">
        `,
        buttons:[{label:"Cerrar", kind:"primary", onClick: closeModal}]
      });
    };

    /* Edges */
    btnEdges.onclick = () => {
      if(!game || !game.running || game.timeUp || game.finished) return;
      setEdgesOnlyMode(!game.edgesOnly);
    };

    /* Organize = re-scatter loose-ish (actually re-pack all again) */
    btnOrganize.onclick = () => {
      if(!game || !game.running || game.timeUp || game.finished) return;
      scatterAllPiecesIntoTrays(game.hb, game.payload.piecesX, game.payload.piecesY);
      viewFitAll();
      setStatus("ok","Organizado","Bordes e interiores reubicados en bandejas.");
    };

    /* Pause */
    btnPause.onclick = () => {
      if(!game || !game.running || game.timeUp || game.finished) return;
      if(!game.paused) pauseGame(); else resumeGame();
    };

    /* Fullscreen */
    btnFullscreen.onclick = async () => {
      try{
        if(!document.fullscreenElement) await document.documentElement.requestFullscreen();
        else await document.exitFullscreen();
      }catch{
        showModal({title:"Info", bodyHTML:"<p>Fullscreen no disponible.</p>", buttons:[{label:"OK", kind:"primary", onClick: closeModal}]});
      }
    };

    /* Mouse wheel zoom */
    $("canvasWrap").addEventListener("wheel", (e) => {
      if(!game || !game.running) return;
      e.preventDefault();
      setZoom(e.deltaY > 0 ? (1/1.10) : 1.10);
    }, {passive:false});

    /* Keyboard shortcuts */
    document.addEventListener("keydown", (e) => {
      if(e.repeat) return;
      if(overlay.getAttribute("aria-hidden")==="false") return;
      const k=(e.key||"").toLowerCase();
      if(k==="t"){ e.preventDefault(); cycleTheme(); }
      if(!game || !game.running) return;
      if(k==="p"){ e.preventDefault(); btnPause.click(); }
      if(k==="r"){ e.preventDefault(); btnReframe.click(); }
      if(k==="o"){ e.preventDefault(); btnOrganize.click(); }
      if(k==="e"){ e.preventDefault(); btnEdges.click(); }
      if(k==="b"){ e.preventDefault(); btnBoxTop.click(); }
      if(k==="+"||k==="="){ e.preventDefault(); btnZoomIn.click(); }
      if(k==="-" ){ e.preventDefault(); btnZoomOut.click(); }
    });

    function disableInitial(){
      btnPause.disabled=true; btnOrganize.disabled=true; btnZoomIn.disabled=true; btnZoomOut.disabled=true;
      btnReframe.disabled=true; btnBoxTop.disabled=true; btnEdges.disabled=true;
      btnEdges.style.display="none"; btnBoxTop.style.display="";
    }
    disableInitial();

    /* Core startGame with FIX */
    async function startGame(payload){
      try{
        await ensureDeps();
        stopTimer();
        destroyStage();

        setTheme(payload.bgTheme || "blue");

        game = {
          running:false, paused:false, solved:false, timeUp:false, finished:false, edgesOnly:false,
          payload,
          hb:null, stage:null,
          zoom:1,
          remainingMs: (payload.solveSeconds|0)*1000,
          lastTick:0,
          timerId:null,
          boxTopDataUrl:null
        };

        setStatus("info","Cargando…","Preparando imagen y puzzle.");
        timerText.textContent = fmtTime(game.remainingMs);

        const imgBlob = new Blob([new Uint8Array(b64ToBuf(payload.img))], {type: payload.mime || "image/jpeg"});
        const imgUrl = URL.createObjectURL(imgBlob);
        const img = new Image(); img.decoding="async"; img.src=imgUrl;
        await new Promise((res, rej)=>{ img.onload=res; img.onerror=()=>rej(new Error("Imagen inválida en el reto.")); });

        game.boxTopDataUrl = await blobToDataURL(imgBlob);
        URL.revokeObjectURL(imgUrl);

        const wrap = $("canvasWrap");
        const rect = wrap.getBoundingClientRect();
        const W = Math.max(320, Math.floor(rect.width));
        const H = Math.max(240, Math.floor(rect.height));

        const px = clamp(parseInt(payload.piecesX,10)||0,2,30);
        const py = clamp(parseInt(payload.piecesY,10)||0,2,30);

        const minSide = Math.min(W, H);
        const desiredFrame = minSide * 0.62;
        const basePiece = desiredFrame / Math.max(px, py);
        const isTouch = matchMedia("(pointer: coarse)").matches;
        const minPiece = isTouch ? 16 : 18;
        const pieceSize = clamp(Math.round(basePiece), minPiece, 140);

        const proximity = clamp(Math.round(pieceSize * 0.22), 6, 22);
        const borderFill = clamp(Math.round(pieceSize * 0.08), 2, 14);

        const hb = new window.headbreaker.Canvas("puzzleCanvas", {
          width: W, height: H,
          fixed: false,
          preventOffstageDrag: false,
          pieceSize,
          proximity,
          borderFill,
          strokeWidth: 1,
          lineSoftness: 0.18,
          outline: new window.headbreaker.outline.Rounded({
            bezelize: true,
            bezelDepth: 0.18,
            insertDepth: 0.92,
            borderLength: 0.26,
            referenceInsertAxis: 0.0
          })
        });

        const total = px*py;
        const metadata = Array.from({length: total}, (_,i)=>({id:"p"+i}));

        const gen =
          (window.headbreaker.generators && window.headbreaker.generators.random) ? window.headbreaker.generators.random :
          undefined;

        hb.autogenerate({
          horizontalPiecesCount: px,
          verticalPiecesCount: py,
          insertsGenerator: gen,
          metadata
        });

        hb.image = img;

        const imgRatio = img.naturalWidth / img.naturalHeight;
        const puzzleRatio = px / py;
        if(imgRatio > puzzleRatio) hb.adjustImagesToPuzzleHeight();
        else hb.adjustImagesToPuzzleWidth();

        // restrict wrong snaps
        attachStrictConnectionRules(hb);

        // lock connections once made
        hb.puzzle.forceConnectionWhileDragging();
        hb.registerKeyboardGestures({}); // disable ctrl/shift gestures that can break

        hb.draw();

        game.hb = hb;
        game.stage = hb["__konvaLayer__"].getStage();

        // identify edges
        annotateGrid(hb, px, py);

        // !!! FIX: move pieces away BEFORE solved validator
        scatterAllPiecesIntoTrays(hb, px, py);

        // Now attach validator (after scatter), so it won't fire instantly
        hb.attachSolvedValidator();
        hb.onValid(async () => { await onSolved(); });

        // enable controls
        game.running = true;
        setEdgesOnlyMode(false);

        // enable interactions + timer
        setInteraction(true);
        disableControls();
        setStatus("info","En juego","(Ya NO empieza resuelto). Conexiones incorrectas desactivadas.");
        viewFitAll();
        startTimer();

      }catch(err){
        stopTimer();
        setStatus("danger","Error","No se pudo inicializar el puzzle.");
        showModal({
          title:"Error",
          bodyHTML:`<p>${escapeHtml(err.message||String(err))}</p>`,
          buttons:[{label:"Cerrar", kind:"primary", onClick: closeModal}]
        });
      }
    }

  })();
  </script>
</body>
</html>

