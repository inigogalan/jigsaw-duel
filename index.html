<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>JPUZ — Crear y Jugar (100% local)</title>
  <style>
    :root{
      --bg0:#0b1220;
      --bg1:#0f1a2e;
      --card: rgba(255,255,255,.06);
      --card2: rgba(255,255,255,.08);
      --text:#eaf0ff;
      --muted: rgba(234,240,255,.75);
      --muted2: rgba(234,240,255,.55);
      --line: rgba(255,255,255,.12);
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --danger:#fb7185;
      --ok:#34d399;
      --warn:#fbbf24;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 16px;
      --btn: rgba(255,255,255,.10);
      --btnh: rgba(255,255,255,.16);
      --btnp: rgba(255,255,255,.22);
      --focus: 0 0 0 3px rgba(125,211,252,.28);
    }

    /* “felt table” (fondo tipo mesa) */
    body{
      margin:0; color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background:
        radial-gradient(1200px 700px at 20% 10%, rgba(125,211,252,.12), transparent 60%),
        radial-gradient(900px 700px at 85% 25%, rgba(167,139,250,.10), transparent 55%),
        radial-gradient(1200px 900px at 45% 100%, rgba(52,211,153,.08), transparent 60%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      min-height:100vh;
      overflow:hidden;
    }

    /* Themes */
    body.theme-blue{
      --bg0:#081427; --bg1:#0b1c39; --accent:#60a5fa; --accent2:#22d3ee;
      background:
        radial-gradient(1200px 700px at 20% 10%, rgba(96,165,250,.12), transparent 60%),
        radial-gradient(900px 700px at 85% 25%, rgba(34,211,238,.10), transparent 55%),
        radial-gradient(1200px 900px at 45% 100%, rgba(52,211,153,.08), transparent 60%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
    }
    body.theme-chalk{
      --bg0:#0b0f14; --bg1:#0f1720; --accent:#a3e635; --accent2:#fbbf24;
      background:
        radial-gradient(1100px 700px at 18% 8%, rgba(163,230,53,.11), transparent 60%),
        radial-gradient(900px 700px at 80% 22%, rgba(251,191,36,.10), transparent 55%),
        radial-gradient(1200px 900px at 45% 100%, rgba(96,165,250,.06), transparent 60%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
    }
    body.theme-forest{
      --bg0:#071412; --bg1:#0a1b16; --accent:#34d399; --accent2:#22c55e;
      background:
        radial-gradient(1100px 700px at 18% 8%, rgba(34,197,94,.12), transparent 60%),
        radial-gradient(900px 700px at 80% 22%, rgba(52,211,153,.10), transparent 55%),
        radial-gradient(1200px 900px at 45% 100%, rgba(125,211,252,.05), transparent 60%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
    }

    a{ color:inherit; }

    .app{
      display:flex; flex-direction:column;
      height:100vh;
    }

    header{
      display:flex; align-items:center; justify-content:space-between;
      padding:14px 16px;
      border-bottom:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      backdrop-filter: blur(10px);
    }
    .brand{
      display:flex; gap:12px; align-items:center;
    }
    .logo{
      width:36px; height:36px; border-radius:12px;
      background: conic-gradient(from 210deg, var(--accent), var(--accent2), rgba(255,255,255,.10));
      box-shadow: var(--shadow);
    }
    .brand h1{
      margin:0; font-size:14px; letter-spacing:.4px;
    }
    .brand .sub{
      display:block; margin-top:2px;
      font-size:12px; color:var(--muted2);
    }

    .tabs{
      display:flex; gap:8px;
      background: rgba(255,255,255,.06);
      border:1px solid var(--line);
      padding:4px; border-radius:999px;
    }
    .tab{
      appearance:none; border:0; background:transparent;
      color:var(--muted);
      padding:8px 12px; border-radius:999px;
      cursor:pointer; font-weight:600; font-size:13px;
    }
    .tab[aria-selected="true"]{
      background: rgba(255,255,255,.12);
      color:var(--text);
    }

    .main{
      display:flex; gap:12px;
      padding:12px;
      flex:1; min-height:0;
    }

    /* Panel lateral (forms) */
    .panel{
      width: 380px;
      max-width: 42vw;
      min-width: 320px;
      background: var(--card);
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:auto;
    }
    .panel-inner{ padding:14px; }
    .panel h2{ margin:0 0 8px; font-size:14px; letter-spacing:.3px; }
    .hint{ font-size:12px; color:var(--muted2); line-height:1.35; }
    .hr{ height:1px; background:var(--line); margin:12px 0; }

    .grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }

    label{
      display:block; font-size:12px; color:var(--muted);
      margin:0 0 6px;
    }
    input[type="text"], input[type="password"], input[type="number"], select{
      width:100%;
      box-sizing:border-box;
      padding:10px 10px;
      border-radius:12px;
      border:1px solid var(--line);
      background: rgba(10,16,28,.55);
      color:var(--text);
      outline:none;
    }
    input:focus, select:focus{ box-shadow: var(--focus); border-color: rgba(125,211,252,.35); }
    input[type="file"]{ width:100%; color:var(--muted); }

    .row{ display:flex; gap:10px; align-items:center; }
    .row > *{ flex:1; }

    .check{
      display:flex; gap:10px; align-items:flex-start;
      padding:10px; border-radius:12px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.04);
    }
    .check input{ margin-top:2px; }
    .check b{ font-size:12px; display:block; }
    .check span{ font-size:12px; color:var(--muted2); display:block; margin-top:2px; line-height:1.35; }

    .btns{ display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }
    button.btn{
      appearance:none; border:1px solid var(--line);
      background: var(--btn);
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
      font-weight:700;
      font-size:13px;
      display:inline-flex; align-items:center; justify-content:center;
      gap:8px;
      user-select:none;
    }
    button.btn:hover{ background: var(--btnh); }
    button.btn:active{ background: var(--btnp); transform: translateY(1px); }
    button.btn:disabled{ opacity:.5; cursor:not-allowed; }
    .btn.primary{ border-color: rgba(125,211,252,.35); }
    .btn.danger{ border-color: rgba(251,113,133,.35); }
    .pill{
      display:inline-flex; padding:4px 8px; border-radius:999px;
      border:1px solid var(--line); background: rgba(255,255,255,.06);
      font-size:12px; color:var(--muted);
      margin-left:8px;
    }

    /* Zona de juego */
    .stage{
      flex:1;
      min-width:0;
      border-radius: var(--radius);
      border:1px solid var(--line);
      background: rgba(255,255,255,.04);
      box-shadow: var(--shadow);
      display:flex;
      flex-direction:column;
      overflow:hidden;
      position:relative;
    }

    .playerbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:10px 12px;
      border-bottom:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      backdrop-filter: blur(10px);
    }

    .status{
      display:flex; gap:10px; align-items:center; min-width:0;
    }
    .status .dot{
      width:10px; height:10px; border-radius:99px; background: var(--accent);
      box-shadow: 0 0 0 3px rgba(125,211,252,.12);
      flex:0 0 auto;
    }
    .status .txt{
      font-weight:800; font-size:13px;
      white-space:nowrap;
      overflow:hidden; text-overflow:ellipsis;
    }
    .status .subtxt{
      display:block; font-weight:600; font-size:12px; color:var(--muted2);
      margin-top:1px;
      white-space:nowrap;
      overflow:hidden; text-overflow:ellipsis;
    }

    .timer{
      font-variant-numeric: tabular-nums;
      font-weight:900;
      letter-spacing:.5px;
      background: rgba(255,255,255,.07);
      border:1px solid var(--line);
      padding:8px 10px;
      border-radius:12px;
      min-width:110px;
      text-align:center;
    }

    .controls{
      display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end;
    }
    .iconbtn{
      appearance:none;
      border:1px solid var(--line);
      background: rgba(255,255,255,.08);
      color:var(--text);
      padding:8px 10px;
      border-radius:12px;
      cursor:pointer;
      font-weight:800;
      font-size:12px;
      display:inline-flex; align-items:center; justify-content:center;
      gap:8px;
      user-select:none;
      white-space:nowrap;
    }
    .iconbtn:hover{ background: rgba(255,255,255,.12); }
    .iconbtn:active{ transform: translateY(1px); }
    .iconbtn:disabled{ opacity:.5; cursor:not-allowed; }

    .canvasWrap{
      position:relative;
      flex:1;
      min-height:0;
      /* clave para móvil: evita scroll “de página” al intentar pan en canvas */
      touch-action:none;
    }
    #puzzleCanvas{
      width:100%;
      height:100%;
      opacity:1;
    }
    .hudNote{
      position:absolute; left:12px; bottom:12px;
      background: rgba(0,0,0,.25);
      border:1px solid rgba(255,255,255,.12);
      padding:8px 10px;
      border-radius:12px;
      font-size:12px;
      color:var(--muted);
      backdrop-filter: blur(8px);
      max-width:min(520px, 92%);
      pointer-events:none;
    }

    /* Overlay modal */
    .overlay{
      position:fixed; inset:0;
      display:none;
      align-items:center; justify-content:center;
      background: rgba(0,0,0,.55);
      backdrop-filter: blur(10px);
      z-index:9999;
      padding:18px;
    }
    .overlay[aria-hidden="false"]{ display:flex; }
    .modal{
      width:min(720px, 96vw);
      max-height: min(86vh, 900px);
      overflow:auto;
      border-radius: 18px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(12,18,30,.90);
      box-shadow: 0 30px 80px rgba(0,0,0,.55);
    }
    .modalHead{
      padding:14px 14px 10px;
      border-bottom:1px solid rgba(255,255,255,.10);
      display:flex; align-items:flex-start; justify-content:space-between; gap:10px;
    }
    .modalHead h3{ margin:0; font-size:14px; letter-spacing:.3px; }
    .modalHead .x{
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.08);
      border-radius:12px;
      padding:8px 10px;
      cursor:pointer;
      font-weight:900;
      color:var(--text);
    }
    .modalBody{ padding:14px; }
    .modalBody p, .modalBody li{
      color:var(--muted);
      font-size:13px;
      line-height:1.45;
    }
    .modalBody code{
      background: rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.10);
      padding:2px 6px;
      border-radius:8px;
    }
    .modalFoot{
      padding:12px 14px 14px;
      border-top:1px solid rgba(255,255,255,.10);
      display:flex; gap:10px; justify-content:flex-end; flex-wrap:wrap;
    }
    .imgPreview{
      width:100%;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.03);
      margin-top:10px;
    }

    .small{
      font-size:12px;
      color:var(--muted2);
    }

    /* Responsive: apila panel en móvil */
    @media (max-width: 980px){
      .main{ flex-direction:column; }
      .panel{ width:auto; max-width:none; min-width:0; }
    }
  </style>
</head>
<body class="theme-blue">
  <div class="app">
    <header>
      <div class="brand">
        <div class="logo" aria-hidden="true"></div>
        <div>
          <h1>JPUZ <span class="pill">100% local</span></h1>
          <span class="sub">Crear → descargar <b>.jpuz</b> → compartir + contraseña → Jugar</span>
        </div>
      </div>

      <div class="tabs" role="tablist" aria-label="Modo">
        <button class="tab" id="tabCreate" role="tab" aria-selected="true">Crear</button>
        <button class="tab" id="tabPlay" role="tab" aria-selected="false">Jugar</button>
      </div>
    </header>

    <div class="main">
      <!-- Panel lateral -->
      <aside class="panel" id="panelCreate" role="tabpanel" aria-labelledby="tabCreate">
        <div class="panel-inner">
          <h2>Crear reto (.jpuz)</h2>
          <div class="hint">
            Todo ocurre en tu navegador: se comprime la imagen, se cifra (PBKDF2 + AES‑GCM) y se descarga un archivo <b>.jpuz</b>.
            <br><br>
            <b>Privacidad práctica:</b> cuando alguien descifra y juega, puede hacer captura de pantalla. No es DRM.
          </div>

          <div class="hr"></div>

          <label>Imagen</label>
          <input type="file" id="c_image" accept="image/*" />
          <img id="c_preview" class="imgPreview" alt="Vista previa" style="display:none" />

          <div class="hr"></div>

          <div class="grid">
            <div>
              <label>Piezas X (2–30)</label>
              <input type="number" id="c_px" min="2" max="30" value="8" />
            </div>
            <div>
              <label>Piezas Y (2–30)</label>
              <input type="number" id="c_py" min="2" max="30" value="6" />
            </div>
            <div>
              <label>Tiempo límite (s)</label>
              <input type="number" id="c_solve" min="5" value="300" />
            </div>
            <div>
              <label>Reveal al completar (s)</label>
              <input type="number" id="c_reveal" min="0" value="6" />
            </div>
          </div>

          <div class="hr"></div>

          <div class="grid">
            <div>
              <label>Tema inicial</label>
              <select id="c_theme">
                <option value="blue">Azul</option>
                <option value="chalk">Pizarra</option>
                <option value="forest">Bosque</option>
              </select>
            </div>
            <div>
              <label>Título (opcional)</label>
              <input type="text" id="c_title" placeholder="Ej: Atardecer" />
            </div>
          </div>

          <div class="hr"></div>

          <div class="check">
            <input type="checkbox" id="c_mystery" />
            <div>
              <b>Mystery mode</b>
              <span>Si está activo, no existe “box top” (no se puede ver la imagen completa durante el juego).</span>
            </div>
          </div>

          <div style="height:10px"></div>

          <div class="check">
            <input type="checkbox" id="c_allowEdgeOnly" checked />
            <div>
              <b>Permitir “Solo bordes”</b>
              <span>El jugador podrá ocultar/mostrar piezas interiores (útil para puzzles grandes).</span>
            </div>
          </div>

          <div class="hr"></div>

          <h2>Compresión</h2>
          <div class="grid">
            <div>
              <label>Max dimensión (px)</label>
              <input type="number" id="c_maxdim" min="256" max="4096" value="1600" />
              <div class="small">Se redimensiona manteniendo proporción.</div>
            </div>
            <div>
              <label>Calidad JPEG (0.5–1.0)</label>
              <input type="number" id="c_quality" min="0.5" max="1.0" step="0.05" value="0.85" />
              <div class="small">Más calidad = más peso.</div>
            </div>
          </div>

          <div class="hr"></div>

          <label>Contraseña (mín. 8 caracteres)</label>
          <input type="password" id="c_pass" minlength="8" placeholder="mínimo 8 caracteres" />

          <div class="btns">
            <button class="btn primary" id="c_generate">Generar y descargar .jpuz</button>
            <button class="btn" id="c_help">Ayuda / atajos</button>
          </div>

          <div class="hr"></div>
          <div class="small">
            Requiere <b>HTTPS</b> (GitHub Pages) porque WebCrypto lo exige.
            <br>
            Estado: <span id="secureBadge">…</span>
          </div>
        </div>
      </aside>

      <aside class="panel" id="panelPlay" role="tabpanel" aria-labelledby="tabPlay" style="display:none">
        <div class="panel-inner">
          <h2>Jugar reto</h2>
          <div class="hint">
            Carga un archivo <b>.jpuz</b> y escribe la contraseña. Se descifra en tu navegador y se inicia el puzzle.
          </div>

          <div class="hr"></div>

          <label>Archivo .jpuz</label>
          <input type="file" id="p_file" accept=".jpuz,application/json" />

          <div class="hr"></div>

          <label>Contraseña</label>
          <input type="password" id="p_pass" minlength="8" placeholder="contraseña del creador" />

          <div class="btns">
            <button class="btn primary" id="p_start">Descifrar e iniciar</button>
            <button class="btn" id="p_help">Ayuda / atajos</button>
          </div>

          <div class="hr"></div>
          <div class="small" id="p_info">Sin reto cargado.</div>
        </div>
      </aside>

      <!-- Zona de juego -->
      <section class="stage" aria-label="Zona de juego">
        <div class="playerbar">
          <div class="status" aria-live="polite">
            <div class="dot" id="statusDot"></div>
            <div style="min-width:0">
              <div class="txt" id="statusText">Listo</div>
              <div class="subtxt" id="statusSub">Crea o carga un reto para empezar.</div>
            </div>
          </div>

          <div class="timer" id="timerText">--:--</div>

          <div class="controls">
            <button class="iconbtn" id="btnBoxTop" title="Box top (B)">Box top</button>
            <button class="iconbtn" id="btnEdges" title="Solo bordes (E)">Solo bordes</button>
            <button class="iconbtn" id="btnOrganize" title="Organizar piezas (O)">Organizar</button>
            <button class="iconbtn" id="btnZoomOut" title="Zoom -">−</button>
            <button class="iconbtn" id="btnZoomIn" title="Zoom +">+</button>
            <button class="iconbtn" id="btnReframe" title="Reencuadrar (R)">Reencuadrar</button>
            <button class="iconbtn" id="btnPause" title="Pausar/Reanudar (P)">Pausa</button>
            <button class="iconbtn" id="btnTheme" title="Cambiar tema (T)">Tema</button>
            <button class="iconbtn" id="btnFullscreen" title="Pantalla completa (opcional)">Fullscreen</button>
          </div>
        </div>

        <div class="canvasWrap" id="canvasWrap">
          <div id="puzzleCanvas"></div>
          <div class="hudNote" id="hudNote">
            Arrastra piezas. Pan: arrastra el fondo. Zoom: botones o rueda.  
            <br><b>B</b> box top, <b>P</b> pausa, <b>T</b> tema, <b>R</b> reencuadrar, <b>O</b> organizar, <b>E</b> solo bordes.
          </div>
        </div>
      </section>
    </div>
  </div>

  <!-- Overlay -->
  <div class="overlay" id="overlay" aria-hidden="true" role="dialog" aria-modal="true">
    <div class="modal">
      <div class="modalHead">
        <h3 id="ovTitle">Mensaje</h3>
        <button class="x" id="ovClose" title="Cerrar (Esc)">✕</button>
      </div>
      <div class="modalBody" id="ovBody"></div>
      <div class="modalFoot" id="ovFoot"></div>
    </div>
  </div>

  <script>
  (() => {
    "use strict";

    /* =========================
       Helpers DOM / UI
    ========================= */
    const $ = (id) => document.getElementById(id);

    const overlay = $("overlay");
    const ovTitle = $("ovTitle");
    const ovBody = $("ovBody");
    const ovFoot = $("ovFoot");
    const ovClose = $("ovClose");

    function escapeHtml(s){
      return String(s).replace(/[&<>"']/g, (c) => ({
        "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
      }[c]));
    }

    function showModal({title, bodyHTML, buttons = []}){
      ovTitle.textContent = title || "Mensaje";
      ovBody.innerHTML = bodyHTML || "";
      ovFoot.innerHTML = "";
      for(const b of buttons){
        const btn = document.createElement("button");
        btn.className = "btn " + (b.kind || "");
        btn.textContent = b.label || "OK";
        btn.onclick = () => { if(b.onClick) b.onClick(); };
        ovFoot.appendChild(btn);
      }
      overlay.setAttribute("aria-hidden", "false");
    }
    function closeModal(){
      overlay.setAttribute("aria-hidden", "true");
      ovTitle.textContent = "Mensaje";
      ovBody.innerHTML = "";
      ovFoot.innerHTML = "";
    }
    ovClose.onclick = closeModal;

    document.addEventListener("keydown", (e) => {
      if(e.key === "Escape"){
        if(overlay.getAttribute("aria-hidden") === "false"){
          e.preventDefault();
          closeModal();
        }
      }
    });

    function setStatus(kind, title, sub){
      const dot = $("statusDot");
      const t = $("statusText");
      const s = $("statusSub");
      t.textContent = title || "";
      s.textContent = sub || "";
      dot.style.background =
        kind === "ok" ? "var(--ok)" :
        kind === "warn" ? "var(--warn)" :
        kind === "danger" ? "var(--danger)" :
        "var(--accent)";
    }

    function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

    function fmtTime(ms){
      ms = Math.max(0, ms|0);
      const totalSec = Math.ceil(ms/1000);
      const m = Math.floor(totalSec/60);
      const s = totalSec % 60;
      return String(m).padStart(2,"0")+":"+String(s).padStart(2,"0");
    }

    /* =========================
       HTTPS / Secure context badge
    ========================= */
    const secureBadge = $("secureBadge");
    if(window.isSecureContext){
      secureBadge.textContent = "OK (secure context)";
    } else {
      secureBadge.textContent = "NO — necesitas HTTPS (GitHub Pages)";
    }

    /* =========================
       Tabs
    ========================= */
    const tabCreate = $("tabCreate");
    const tabPlay = $("tabPlay");
    const panelCreate = $("panelCreate");
    const panelPlay = $("panelPlay");

    function setMode(mode){
      const isCreate = mode === "create";
      tabCreate.setAttribute("aria-selected", isCreate ? "true":"false");
      tabPlay.setAttribute("aria-selected", !isCreate ? "true":"false");
      panelCreate.style.display = isCreate ? "" : "none";
      panelPlay.style.display = !isCreate ? "" : "none";
    }
    tabCreate.onclick = () => setMode("create");
    tabPlay.onclick = () => setMode("play");

    /* =========================
       Dynamic dependency loader (fix “headbreaker is not defined”)
    ========================= */
    async function loadScript(url){
      return new Promise((resolve, reject) => {
        const s = document.createElement("script");
        s.src = url;
        s.async = true;
        s.onload = () => resolve(url);
        s.onerror = () => reject(new Error("No se pudo cargar: " + url));
        document.head.appendChild(s);
      });
    }

    async function ensureLib(name, testFn, urls){
      if(testFn()) return;
      let lastErr = null;
      for(const u of urls){
        try{
          await loadScript(u);
          if(testFn()) return;
        }catch(e){
          lastErr = e;
        }
      }
      throw new Error(`${name} no se pudo cargar. ${lastErr ? lastErr.message : ""}`);
    }

    async function ensureDeps(){
      await ensureLib("Konva",
        () => !!window.Konva,
        [
          "https://cdnjs.cloudflare.com/ajax/libs/konva/9.3.0/konva.min.js",
          "https://cdn.jsdelivr.net/npm/konva@9.3.0/konva.min.js"
        ]
      );
      await ensureLib("Headbreaker",
        () => !!window.headbreaker,
        [
          "https://flbulgarelli.github.io/headbreaker/js/headbreaker.js",
          "https://cdn.jsdelivr.net/gh/flbulgarelli/headbreaker@master/js/headbreaker.js"
        ]
      );
    }

    /* =========================
       Base64 helpers
    ========================= */
    function bufToB64(buf){
      const bytes = new Uint8Array(buf);
      let bin = "";
      const chunk = 0x8000;
      for(let i=0;i<bytes.length;i+=chunk){
        bin += String.fromCharCode(...bytes.subarray(i, i+chunk));
      }
      return btoa(bin);
    }

    function b64ToBuf(b64){
      const bin = atob(b64);
      const bytes = new Uint8Array(bin.length);
      for(let i=0;i<bin.length;i++) bytes[i] = bin.charCodeAt(i);
      return bytes.buffer;
    }

    function dataUrlToB64(dataUrl){
      const idx = dataUrl.indexOf("base64,");
      if(idx === -1) return "";
      return dataUrl.slice(idx + 7);
    }

    function blobToDataURL(blob){
      return new Promise((resolve, reject) => {
        const fr = new FileReader();
        fr.onload = () => resolve(fr.result);
        fr.onerror = () => reject(new Error("No se pudo leer el blob"));
        fr.readAsDataURL(blob);
      });
    }

    /* =========================
       Crypto (PBKDF2 + AES-GCM)
    ========================= */
    const KDF = "PBKDF2";
    const ALG = "AES-GCM";
    const PBKDF2_ITER = 150000; // razonable para navegador moderno

    async function deriveKey(password, saltB64, iter){
      const enc = new TextEncoder();
      const baseKey = await crypto.subtle.importKey(
        "raw",
        enc.encode(password),
        {name: "PBKDF2"},
        false,
        ["deriveKey"]
      );

      const key = await crypto.subtle.deriveKey(
        {name:"PBKDF2", salt: new Uint8Array(b64ToBuf(saltB64)), iterations: iter, hash:"SHA-256"},
        baseKey,
        {name:"AES-GCM", length: 256},
        false,
        ["encrypt","decrypt"]
      );
      return key;
    }

    async function encryptPayload(payloadObj, password){
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const iter = PBKDF2_ITER;

      const key = await deriveKey(password, bufToB64(salt.buffer), iter);
      const enc = new TextEncoder();
      const pt = enc.encode(JSON.stringify(payloadObj));

      const ctBuf = await crypto.subtle.encrypt({name:"AES-GCM", iv}, key, pt);

      return {
        v: 1,
        kdf: KDF,
        iter,
        salt: bufToB64(salt.buffer),
        alg: ALG,
        iv: bufToB64(iv.buffer),
        ct: bufToB64(ctBuf)
      };
    }

    async function decryptChallenge(challengeObj, password){
      if(!challengeObj || typeof challengeObj !== "object") throw new Error("Archivo inválido (no es JSON objeto).");
      const {v, kdf, iter, salt, alg, iv, ct} = challengeObj;
      if(v !== 1) throw new Error("Versión .jpuz no soportada.");
      if(kdf !== "PBKDF2") throw new Error("KDF no soportado.");
      if(alg !== "AES-GCM") throw new Error("Algoritmo no soportado.");
      if(!iter || !salt || !iv || !ct) throw new Error("Faltan campos requeridos en .jpuz.");

      const key = await deriveKey(password, salt, iter);
      let ptBuf;
      try{
        ptBuf = await crypto.subtle.decrypt(
          {name:"AES-GCM", iv: new Uint8Array(b64ToBuf(iv))},
          key,
          b64ToBuf(ct)
        );
      }catch{
        throw new Error("Contraseña incorrecta o archivo corrupto (AES-GCM no autentica).");
      }

      const dec = new TextDecoder();
      const json = dec.decode(ptBuf);
      let payload;
      try{
        payload = JSON.parse(json);
      }catch{
        throw new Error("Payload descifrado no es JSON válido.");
      }
      return payload;
    }

    /* =========================
       Image compression
    ========================= */
    async function decodeImageFromFile(file){
      // prefer createImageBitmap, fallback to <img>
      if("createImageBitmap" in window){
        try{
          const bmp = await createImageBitmap(file);
          return {kind:"bitmap", obj:bmp, width:bmp.width, height:bmp.height};
        }catch{}
      }
      const url = URL.createObjectURL(file);
      const img = new Image();
      img.decoding = "async";
      img.src = url;
      await new Promise((resolve, reject) => {
        img.onload = resolve;
        img.onerror = () => reject(new Error("No se pudo decodificar la imagen"));
      });
      URL.revokeObjectURL(url);
      return {kind:"img", obj:img, width:img.naturalWidth, height:img.naturalHeight};
    }

    async function compressToJpegBase64(file, maxDim, quality){
      const decoded = await decodeImageFromFile(file);
      const w0 = decoded.width, h0 = decoded.height;
      const scale = Math.min(1, maxDim / Math.max(w0, h0));
      const w = Math.max(1, Math.round(w0 * scale));
      const h = Math.max(1, Math.round(h0 * scale));

      // yield to UI
      await new Promise(r => requestAnimationFrame(r));

      const c = document.createElement("canvas");
      c.width = w; c.height = h;
      const ctx = c.getContext("2d", {alpha:false});
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = "high";

      if(decoded.kind === "bitmap"){
        ctx.drawImage(decoded.obj, 0, 0, w, h);
        try{ decoded.obj.close(); }catch{}
      } else {
        ctx.drawImage(decoded.obj, 0, 0, w, h);
      }

      const blob = await new Promise((resolve) => c.toBlob(resolve, "image/jpeg", quality));
      if(!blob) throw new Error("No se pudo generar JPEG (toBlob devolvió null).");
      const dataUrl = await blobToDataURL(blob);
      return {
        mime: "image/jpeg",
        imgB64: dataUrlToB64(dataUrl),
        outW: w,
        outH: h
      };
    }

    /* =========================
       Create mode
    ========================= */
    const c_image = $("c_image");
    const c_preview = $("c_preview");
    c_image.addEventListener("change", async () => {
      const f = c_image.files && c_image.files[0];
      if(!f) return;
      const url = URL.createObjectURL(f);
      c_preview.src = url;
      c_preview.style.display = "";
      c_preview.onload = () => URL.revokeObjectURL(url);
    });

    $("c_help").onclick = () => {
      showModal({
        title: "Ayuda (Crear/Jugar) y atajos",
        bodyHTML: `
          <p><b>Flujo:</b> Crear → descargar <code>.jpuz</code> → compartir archivo + contraseña → Jugar.</p>
          <p><b>Atajos (Jugar):</b></p>
          <ul>
            <li><b>B</b>: box top (si no es mystery)</li>
            <li><b>P</b>: pausar/reanudar</li>
            <li><b>T</b>: cambiar tema</li>
            <li><b>R</b>: reencuadrar (encuadra piezas + frame)</li>
            <li><b>O</b>: organizar piezas sueltas en bandejas</li>
            <li><b>E</b>: solo bordes (si el reto lo permite)</li>
            <li><b>Esc</b>: cerrar overlays</li>
          </ul>
          <p class="small">
            Privacidad práctica: una vez descifrado, no se puede impedir al 100% que alguien capture pantalla.
          </p>
        `,
        buttons: [{label:"Cerrar", kind:"primary", onClick: closeModal}]
      });
    };

    $("c_generate").onclick = async () => {
      try{
        if(!window.isSecureContext){
          throw new Error("Necesitas HTTPS (GitHub Pages) para usar WebCrypto.");
        }
        const f = c_image.files && c_image.files[0];
        if(!f) throw new Error("Selecciona una imagen.");
        const piecesX = clamp(parseInt($("c_px").value,10)||0, 2, 30);
        const piecesY = clamp(parseInt($("c_py").value,10)||0, 2, 30);
        const solveSeconds = Math.max(5, parseInt($("c_solve").value,10)||0);
        const revealSeconds = Math.max(0, parseInt($("c_reveal").value,10)||0);
        const mystery = !!$("c_mystery").checked;
        const bgTheme = $("c_theme").value || "blue";
        const title = ($("c_title").value || "").trim();
        const allowEdgeOnly = !!$("c_allowEdgeOnly").checked;

        const maxDim = clamp(parseInt($("c_maxdim").value,10)||1600, 256, 4096);
        const quality = clamp(parseFloat($("c_quality").value)||0.85, 0.5, 1.0);

        const password = $("c_pass").value || "";
        if(password.length < 8) throw new Error("La contraseña debe tener al menos 8 caracteres.");

        showModal({
          title: "Procesando…",
          bodyHTML: `<p>Comprimiendo imagen y cifrando…</p><p class="small">Nada se sube a servidor.</p>`,
          buttons: []
        });

        const comp = await compressToJpegBase64(f, maxDim, quality);

        const payload = {
          v: 1,
          createdAt: new Date().toISOString(),
          title,
          mime: comp.mime,
          img: comp.imgB64,
          piecesX, piecesY,
          solveSeconds,
          revealSeconds,
          mystery,
          bgTheme,
          allowEdgeOnly
        };

        const envelope = await encryptPayload(payload, password);
        const blob = new Blob([JSON.stringify(envelope, null, 2)], {type:"application/json"});
        const a = document.createElement("a");
        const fileName = "reto.jpuz";
        a.href = URL.createObjectURL(blob);
        a.download = fileName;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(()=>URL.revokeObjectURL(a.href), 1500);

        closeModal();
        setStatus("ok","Reto generado","Descargado como reto.jpuz (compártelo junto a la contraseña).");
      }catch(err){
        showModal({
          title: "Error",
          bodyHTML: `<p>${escapeHtml(err.message || String(err))}</p>`,
          buttons: [{label:"Cerrar", kind:"primary", onClick: closeModal}]
        });
        setStatus("danger","Error","No se pudo generar el reto.");
      }
    };

    /* =========================
       Play mode
    ========================= */
    const p_info = $("p_info");

    $("p_help").onclick = $("c_help").onclick;

    let lastPayload = null;

    $("p_start").onclick = async () => {
      try{
        if(!window.isSecureContext){
          throw new Error("Necesitas HTTPS (GitHub Pages) para usar WebCrypto.");
        }
        const file = $("p_file").files && $("p_file").files[0];
        if(!file) throw new Error("Selecciona un archivo .jpuz.");
        const password = $("p_pass").value || "";
        if(password.length < 8) throw new Error("Contraseña demasiado corta.");

        showModal({
          title:"Descifrando…",
          bodyHTML:`<p>Descifrando localmente…</p><p class="small">Si la contraseña es incorrecta, fallará.</p>`,
          buttons:[]
        });

        const text = await file.text();
        let obj;
        try{ obj = JSON.parse(text); }catch{ throw new Error("El archivo .jpuz no es JSON válido."); }

        const payload = await decryptChallenge(obj, password);

        // Validate minimal fields
        const needed = ["mime","img","piecesX","piecesY","solveSeconds","revealSeconds","mystery","bgTheme"];
        for(const k of needed){
          if(payload[k] === undefined) throw new Error("Payload descifrado incompleto: falta " + k);
        }

        lastPayload = payload;

        p_info.innerHTML =
          `Reto cargado: <b>${escapeHtml(payload.title || "Sin título")}</b><br>`+
          `Piezas: <b>${payload.piecesX}×${payload.piecesY}</b> · Tiempo: <b>${payload.solveSeconds}s</b> · Reveal: <b>${payload.revealSeconds}s</b><br>`+
          `Mystery: <b>${payload.mystery ? "sí":"no"}</b> · Solo bordes permitido: <b>${payload.allowEdgeOnly ? "sí":"no"}</b>`;

        closeModal();
        await startGame(payload);
      }catch(err){
        showModal({
          title:"Error",
          bodyHTML:`<p>${escapeHtml(err.message || String(err))}</p>`,
          buttons:[{label:"Cerrar", kind:"primary", onClick: closeModal}]
        });
        setStatus("danger","Error","No se pudo iniciar el juego.");
      }
    };

    /* =========================
       Game logic (Headbreaker)
    ========================= */
    const timerText = $("timerText");

    const btnBoxTop = $("btnBoxTop");
    const btnEdges = $("btnEdges");
    const btnOrganize = $("btnOrganize");
    const btnZoomIn = $("btnZoomIn");
    const btnZoomOut = $("btnZoomOut");
    const btnReframe = $("btnReframe");
    const btnPause = $("btnPause");
    const btnTheme = $("btnTheme");
    const btnFullscreen = $("btnFullscreen");

    let game = null;

    function setTheme(theme){
      document.body.classList.remove("theme-blue","theme-chalk","theme-forest");
      const t = theme === "chalk" ? "theme-chalk" : theme === "forest" ? "theme-forest" : "theme-blue";
      document.body.classList.add(t);
    }

    function cycleTheme(){
      const cur = document.body.classList.contains("theme-chalk") ? "chalk"
               : document.body.classList.contains("theme-forest") ? "forest"
               : "blue";
      const next = cur === "blue" ? "chalk" : cur === "chalk" ? "forest" : "blue";
      setTheme(next);
      if(game && game.payload) game.payload.bgTheme = next;
    }

    btnTheme.onclick = cycleTheme;

    btnFullscreen.onclick = async () => {
      try{
        if(!document.fullscreenElement){
          await document.documentElement.requestFullscreen();
        }else{
          await document.exitFullscreen();
        }
      }catch{
        showModal({title:"Info", bodyHTML:`<p>Fullscreen no disponible en este navegador.</p>`,
          buttons:[{label:"OK", kind:"primary", onClick: closeModal}]});
      }
    };

    function destroyStage(){
      try{
        if(game && game.stage){
          game.stage.destroy();
        }
      }catch{}
      $("puzzleCanvas").innerHTML = "";
    }

    function disableControlsDisabledState(){
      const running = !!(game && game.running);
      btnPause.disabled = !running;
      btnOrganize.disabled = !running;
      btnZoomIn.disabled = !running;
      btnZoomOut.disabled = !running;
      btnReframe.disabled = !running;
      btnFullscreen.disabled = false;
      btnTheme.disabled = false;

      // Box top: only if running + not mystery + not timeUp
      const allowBoxTop = running && game && !game.payload.mystery && !game.timeUp;
      btnBoxTop.disabled = !allowBoxTop;
      btnBoxTop.style.display = game && game.payload && game.payload.mystery ? "none" : "";

      // Solo bordes: only if allowed by payload
      const allowEdges = running && game && !!game.payload.allowEdgeOnly && !game.timeUp;
      btnEdges.disabled = !allowEdges;
      btnEdges.style.display = (game && game.payload && game.payload.allowEdgeOnly) ? "" : "none";
    }

    function setInteraction(enabled){
      if(!game || !game.hb) return;
      try{
        // stage pan
        game.stage.draggable(enabled && !game.timeUp && !game.finished);
      }catch{}
      // pieces drag
      for(const p of game.hb.puzzle.pieces){
        const fig = game.hb.getFigure(p);
        if(!fig || !fig.group) continue;
        const visible = fig.group.visible();
        fig.group.draggable(!!(enabled && visible && !game.timeUp && !game.finished));
      }
    }

    function computePuzzleFrameDims(hb, piecesX, piecesY){
      const stepX = hb.puzzle.pieceDiameter.x;
      const stepY = hb.puzzle.pieceDiameter.y;
      return { w: stepX * piecesX, h: stepY * piecesY };
    }

    function annotateGrid(hb, piecesX, piecesY){
      const pieces = hb.puzzle.pieces;
      let minX = Infinity, minY = Infinity;
      for(const p of pieces){
        const tp = p.metadata.targetPosition;
        if(tp){
          minX = Math.min(minX, tp.x);
          minY = Math.min(minY, tp.y);
        }
      }
      const stepX = hb.puzzle.pieceDiameter.x;
      const stepY = hb.puzzle.pieceDiameter.y;
      const eps = Math.max(1, Math.min(stepX, stepY) * 0.01);

      for(const p of pieces){
        const tp = p.metadata.targetPosition;
        if(!tp) continue;
        const col = clamp(Math.round((tp.x - minX) / stepX), 0, piecesX-1);
        const row = clamp(Math.round((tp.y - minY) / stepY), 0, piecesY-1);
        p.metadata._grid = {row, col};
        p.metadata._isEdge = (row === 0 || col === 0 || row === piecesY-1 || col === piecesX-1);
        p.metadata._gridEps = eps;
        p.metadata._gridStep = {x: stepX, y: stepY};
      }
    }

    function attachStrictConnectionRules(hb){
      // Only connect real neighbors based on targetPosition grid spacing.
      const pieces = hb.puzzle.pieces;

      // derive step and tolerances
      const stepX = hb.puzzle.pieceDiameter.x;
      const stepY = hb.puzzle.pieceDiameter.y;
      const eps = Math.max(1, Math.min(stepX, stepY) * 0.02);

      function isNeighborH(a, b){
        const ta = a.metadata.targetPosition, tb = b.metadata.targetPosition;
        if(!ta || !tb) return false;
        const sameRow = Math.abs(ta.y - tb.y) <= eps;
        const dx = Math.abs(ta.x - tb.x);
        return sameRow && Math.abs(dx - stepX) <= eps;
      }
      function isNeighborV(a, b){
        const ta = a.metadata.targetPosition, tb = b.metadata.targetPosition;
        if(!ta || !tb) return false;
        const sameCol = Math.abs(ta.x - tb.x) <= eps;
        const dy = Math.abs(ta.y - tb.y);
        return sameCol && Math.abs(dy - stepY) <= eps;
      }

      hb.puzzle.attachHorizontalConnectionRequirement((a,b) => isNeighborH(a,b));
      hb.puzzle.attachVerticalConnectionRequirement((a,b) => isNeighborV(a,b));
    }

    function addTargetFrameRect(hb, frameW, frameH){
      try{
        const layer = hb["__konvaLayer__"];
        if(!layer || !window.Konva) return null;
        const rect = new Konva.Rect({
          x: 0, y: 0,
          width: frameW, height: frameH,
          stroke: "rgba(255,255,255,0.28)",
          dash: [10, 8],
          strokeWidth: 2,
          listening: false
        });
        layer.add(rect);
        rect.moveToBottom();
        layer.draw();
        return rect;
      }catch{
        return null;
      }
    }

    function arrangeLoosePiecesInTrays(){
      if(!game || !game.hb) return;
      const hb = game.hb;
      const px = game.payload.piecesX, py = game.payload.piecesY;
      const {w:frameW, h:frameH} = computePuzzleFrameDims(hb, px, py);

      const pieces = hb.puzzle.pieces;

      const loose = pieces.filter(p => !p.connected); // solo piezas sueltas
      // shuffle (para que no siempre quede igual)
      for(let i=loose.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [loose[i], loose[j]] = [loose[j], loose[i]];
      }

      const edge = loose.filter(p => !!p.metadata._isEdge);
      const inner = loose.filter(p => !p.metadata._isEdge);

      const pieceSize = hb.puzzle.pieceDiameter.x; // approx
      const cell = pieceSize * 1.08;
      const gap = pieceSize * 0.55;

      // trays: izquierda (bordes), derecha (interior)
      const trayW = Math.max(frameW * 0.70, pieceSize * 9);
      const left = { x: -trayW - gap, y: 0, w: trayW };
      const right= { x: frameW + gap, y: 0, w: trayW };

      function pack(list, tray){
        const cols = Math.max(1, Math.floor(tray.w / cell));
        for(let i=0;i<list.length;i++){
          const p = list[i];
          const cx = tray.x + (i % cols) * cell + pieceSize/2;
          const cy = tray.y + Math.floor(i / cols) * cell + pieceSize/2;
          const jitter = (Math.random()-0.5) * pieceSize * 0.10;
          const pos = p.centralAnchor.asVector();
          p.push((cx + jitter) - pos.x, (cy + jitter) - pos.y);
        }
      }

      pack(edge, left);
      pack(inner, right);
      hb.redraw();
    }

    function setEdgesOnlyMode(enabled){
      if(!game || !game.hb) return;
      if(!game.payload.allowEdgeOnly) return;
      game.edgesOnly = !!enabled;

      const hb = game.hb;
      for(const p of hb.puzzle.pieces){
        const fig = hb.getFigure(p);
        if(!fig || !fig.group) continue;
        const show = (!game.edgesOnly) || !!p.metadata._isEdge;
        fig.group.visible(show);
        fig.group.listening(show);
        // drag state
        fig.group.draggable(show && !game.paused && !game.timeUp && !game.finished);
      }
      hb.redraw();
      btnEdges.textContent = game.edgesOnly ? "Mostrar todo" : "Solo bordes";
    }

    function viewHome(){
      if(!game || !game.hb) return;
      const hb = game.hb;
      const wrap = $("canvasWrap");
      const r = wrap.getBoundingClientRect();

      const px = game.payload.piecesX, py = game.payload.piecesY;
      const {w:frameW, h:frameH} = computePuzzleFrameDims(hb, px, py);

      // Fit frame with margin
      const margin = 26;
      const scale = clamp(0.92 * Math.min((r.width - margin) / frameW, (r.height - margin) / frameH), 0.25, 2.0);

      game.zoom = scale;
      try{
        // Use headbreaker scale (so drag deltas stay coherent)
        hb.scale(scale);
      }catch{
        game.stage.scale({x:scale,y:scale});
      }

      const x = (r.width - frameW * scale) / 2;
      const y = (r.height - frameH * scale) / 2;
      game.stage.position({x, y});
      game.stage.batchDraw();
    }

    function viewFitAll(){
      if(!game || !game.hb) return;
      const hb = game.hb;
      const wrap = $("canvasWrap");
      const r = wrap.getBoundingClientRect();

      const pieces = hb.puzzle.pieces;
      const rad = hb.puzzle.pieceRadius;

      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      for(const p of pieces){
        const pos = p.centralAnchor.asVector();
        minX = Math.min(minX, pos.x - rad.x);
        minY = Math.min(minY, pos.y - rad.y);
        maxX = Math.max(maxX, pos.x + rad.x);
        maxY = Math.max(maxY, pos.y + rad.y);
      }
      // include target frame always
      const px = game.payload.piecesX, py = game.payload.piecesY;
      const {w:frameW, h:frameH} = computePuzzleFrameDims(hb, px, py);
      minX = Math.min(minX, 0); minY = Math.min(minY, 0);
      maxX = Math.max(maxX, frameW); maxY = Math.max(maxY, frameH);

      const bw = maxX - minX, bh = maxY - minY;
      const margin = 36;
      const scale = clamp(0.92 * Math.min((r.width - margin)/bw, (r.height - margin)/bh), 0.18, 2.2);
      game.zoom = scale;

      try{ hb.scale(scale); }catch{ game.stage.scale({x:scale,y:scale}); }

      const x = (r.width - bw*scale)/2 - minX*scale;
      const y = (r.height - bh*scale)/2 - minY*scale;
      game.stage.position({x,y});
      game.stage.batchDraw();
    }

    function setZoom(delta){
      if(!game || !game.hb) return;
      const hb = game.hb;
      const wrap = $("canvasWrap");
      const r = wrap.getBoundingClientRect();

      const old = game.zoom || 1;
      const next = clamp(old * delta, 0.18, 2.4);

      // zoom around center of viewport
      const center = {x: r.width/2, y: r.height/2};
      const stage = game.stage;
      const stagePos = stage.position();
      const mousePointTo = {
        x: (center.x - stagePos.x) / old,
        y: (center.y - stagePos.y) / old
      };

      game.zoom = next;
      try{ hb.scale(next); }catch{ stage.scale({x:next,y:next}); }

      const newPos = {
        x: center.x - mousePointTo.x * next,
        y: center.y - mousePointTo.y * next
      };
      stage.position(newPos);
      stage.batchDraw();
    }

    btnZoomIn.onclick = () => setZoom(1.12);
    btnZoomOut.onclick = () => setZoom(1/1.12);

    btnReframe.onclick = () => viewFitAll();

    btnOrganize.onclick = () => {
      if(!game || !game.running || game.timeUp || game.finished) return;
      arrangeLoosePiecesInTrays();
      // tras organizar, encuadra para que se vea el conjunto
      viewFitAll();
      setStatus("ok","Organizado","Piezas sueltas ordenadas en bandejas (bordes/centro).");
    };

    btnEdges.onclick = () => {
      if(!game || !game.running || game.timeUp || game.finished) return;
      setEdgesOnlyMode(!game.edgesOnly);
    };

    btnBoxTop.onclick = () => {
      if(!game || !game.running) return;
      if(game.payload.mystery) return;
      if(game.timeUp) return;

      showModal({
        title: "Box top",
        bodyHTML: `
          <p><b>${escapeHtml(game.payload.title || "Imagen")}</b></p>
          <p class="small">Nota: no es posible evitar capturas de pantalla una vez descifrado.</p>
          <img class="imgPreview" alt="Box top" src="${game.boxTopDataUrl}">
        `,
        buttons: [{label:"Cerrar", kind:"primary", onClick: closeModal}]
      });
    };

    btnPause.onclick = () => {
      if(!game || !game.running || game.timeUp || game.finished) return;
      if(!game.paused){
        pauseGame();
      }else{
        resumeGame();
      }
    };

    function pauseGame(){
      if(!game) return;
      game.paused = true;
      setInteraction(false);
      setStatus("warn","Pausado","Pulsa P o el botón Pausa para reanudar.");
      showModal({
        title: "Pausado",
        bodyHTML: `<p>El temporizador está detenido.</p>`,
        buttons: [
          {label:"Reanudar", kind:"primary", onClick: () => { closeModal(); resumeGame(); }},
          {label:"Reencuadrar", onClick: () => { closeModal(); viewFitAll(); }}
        ]
      });
      btnPause.textContent = "Reanudar";
    }

    function resumeGame(){
      if(!game) return;
      game.paused = false;
      game.lastTick = performance.now();
      setInteraction(true);
      setStatus("info","En juego","Arrastra piezas. Pan con el fondo. Zoom disponible.");
      btnPause.textContent = "Pausa";
      disableControlsDisabledState();
    }

    /* Timer */
    function startTimer(){
      if(!game) return;
      game.remainingMs = (game.payload.solveSeconds|0) * 1000;
      game.lastTick = performance.now();
      timerText.textContent = fmtTime(game.remainingMs);

      if(game.timerId) clearInterval(game.timerId);
      game.timerId = setInterval(() => {
        if(!game || !game.running) return;
        if(game.paused || game.solved || game.timeUp || game.finished) return;
        const now = performance.now();
        const dt = now - game.lastTick;
        game.lastTick = now;
        game.remainingMs = Math.max(0, game.remainingMs - dt);
        timerText.textContent = fmtTime(game.remainingMs);
        if(game.remainingMs <= 0){
          onTimeUp();
        }
      }, 200);
    }

    function stopTimer(){
      if(game && game.timerId){
        clearInterval(game.timerId);
        game.timerId = null;
      }
    }

    function onTimeUp(){
      if(!game || game.timeUp || game.solved) return;
      game.timeUp = true;
      stopTimer();
      setInteraction(false);
      disableControlsDisabledState();
      setStatus("danger","Tiempo agotado","No se muestra la imagen. Puedes reiniciar.");

      showModal({
        title: "Tiempo agotado",
        bodyHTML: `<p>Se terminó el tiempo.</p><p class="small">La imagen no se revela. Reinicia para intentarlo de nuevo.</p>`,
        buttons: [
          {label:"Reiniciar", kind:"primary", onClick: async () => { closeModal(); await restartGame(); }},
          {label:"Salir", onClick: () => { closeModal(); }}
        ]
      });
    }

    async function onSolved(){
      if(!game || game.solved || game.timeUp) return;
      game.solved = true;
      stopTimer();
      setInteraction(false);
      disableControlsDisabledState();
      setStatus("ok","¡Resuelto!","Revelando imagen…");

      // Reveal for revealSeconds
      const rs = Math.max(0, game.payload.revealSeconds|0);
      showModal({
        title: "¡Completado!",
        bodyHTML: `
          <p>¡Puzzle resuelto dentro del tiempo!</p>
          <p class="small">Revelando durante <b>${rs}s</b>… (después: Fin)</p>
          <img class="imgPreview" alt="Revelado" src="${game.boxTopDataUrl}">
        `,
        buttons: []
      });

      if(rs > 0){
        await new Promise(r => setTimeout(r, rs*1000));
      } else {
        await new Promise(r => setTimeout(r, 400));
      }

      closeModal();
      game.finished = true;
      setStatus("ok","Fin","Puedes reiniciar o cargar otro reto.");
      showModal({
        title: "Fin",
        bodyHTML: `<p>Gracias por jugar.</p>`,
        buttons: [
          {label:"Reiniciar", kind:"primary", onClick: async () => { closeModal(); await restartGame(); }},
          {label:"Cerrar", onClick: closeModal}
        ]
      });
    }

    async function restartGame(){
      if(!lastPayload) return;
      await startGame(lastPayload, {restart:true});
    }

    /* Start game */
    async function startGame(payload, opts = {}){
      try{
        // deps
        await ensureDeps();

        // UI theme from payload
        setTheme(payload.bgTheme || "blue");

        // cleanup
        stopTimer();
        destroyStage();

        // reset state
        game = {
          running: false,
          paused: false,
          solved: false,
          timeUp: false,
          finished: false,
          edgesOnly: false,
          payload,
          hb: null,
          stage: null,
          zoom: 1,
          timerId: null,
          remainingMs: (payload.solveSeconds|0) * 1000,
          lastTick: 0,
          boxTopDataUrl: null
        };

        // update buttons vis
        btnEdges.textContent = "Solo bordes";

        setStatus("info","Cargando puzzle…","Preparando motor y decodificando imagen.");
        timerText.textContent = fmtTime(game.remainingMs);

        // decode image from base64
        const imgBlob = new Blob([new Uint8Array(b64ToBuf(payload.img))], {type: payload.mime || "image/jpeg"});
        const imgUrl = URL.createObjectURL(imgBlob);

        const img = new Image();
        img.decoding = "async";
        img.src = imgUrl;
        await new Promise((resolve, reject) => {
          img.onload = resolve;
          img.onerror = () => reject(new Error("Imagen inválida en el reto."));
        });

        // Keep a dataURL for box top overlays (avoid object URL lifetime issues)
        const dataUrl = await blobToDataURL(imgBlob);
        game.boxTopDataUrl = dataUrl;

        // setup canvas sizes
        const wrap = $("canvasWrap");
        const rect = wrap.getBoundingClientRect();
        const W = Math.max(320, Math.floor(rect.width));
        const H = Math.max(240, Math.floor(rect.height));

        const piecesX = clamp(parseInt(payload.piecesX,10)||0, 2, 30);
        const piecesY = clamp(parseInt(payload.piecesY,10)||0, 2, 30);

        // dynamic piece size: keep 30x30 reasonable
        const minSide = Math.min(W, H);
        const desiredFrame = minSide * 0.62;
        const basePiece = desiredFrame / Math.max(piecesX, piecesY);
        const isTouch = matchMedia("(pointer: coarse)").matches;
        const minPiece = isTouch ? 16 : 18;
        const maxPiece = 140;
        const pieceSize = clamp(Math.round(basePiece), minPiece, maxPiece);

        const proximity = clamp(Math.round(pieceSize * 0.22), 6, 22);
        const borderFill = clamp(Math.round(pieceSize * 0.08), 2, 14);
        const strokeWidth = 1;
        const lineSoftness = 0.18;

        // choose inserts generator
        const gen =
          (window.headbreaker.generators && window.headbreaker.generators.random) ? window.headbreaker.generators.random :
          (window.headbreaker.sequence && window.headbreaker.sequence.random) ? window.headbreaker.sequence.random :
          undefined;

        // create hb canvas
        const hb = new window.headbreaker.Canvas("puzzleCanvas", {
          width: W,
          height: H,
          fixed: false,              // allow stage pan (drag background)
          preventOffstageDrag: false, // allow pieces to go out of view (recover with reframe)
          pieceSize,
          proximity,
          borderFill,
          strokeWidth,
          lineSoftness,
          outline: new window.headbreaker.outline.Rounded({
            bezelize: true,
            bezelDepth: 0.18,
            insertDepth: 0.92,
            borderLength: 0.26,
            referenceInsertAxis: 0.0
          })
        });

        const total = piecesX * piecesY;
        const metadata = Array.from({length: total}, (_,i)=>({id: "p"+i}));

        hb.autogenerate({
          horizontalPiecesCount: piecesX,
          verticalPiecesCount: piecesY,
          insertsGenerator: gen,
          metadata
        });

        hb.image = img;

        // adjust image fit to puzzle
        const imgRatio = img.naturalWidth / img.naturalHeight;
        const puzzleRatio = piecesX / piecesY;
        if(imgRatio > puzzleRatio){
          hb.adjustImagesToPuzzleHeight();
        }else{
          hb.adjustImagesToPuzzleWidth();
        }

        // strict connection rules (fix “snap wrong”)
        attachStrictConnectionRules(hb);

        // lock connections permanently
        hb.puzzle.forceConnectionWhileDragging();
        // Disable default ctrl/shift drag-mode gestures (so no forced disconnection)
        hb.registerKeyboardGestures({});

        // solved validator
        hb.attachSolvedValidator();
        hb.onValid(async () => {
          // Only fire once
          await onSolved();
        });

        // draw (avoid flash of solved state)
        $("puzzleCanvas").style.opacity = "0";
        hb.draw();

        // keep references
        game.hb = hb;
        game.stage = hb["__konvaLayer__"].getStage();

        // annotate grid for edge detection
        annotateGrid(hb, piecesX, piecesY);

        // add target frame rect
        const {w:frameW, h:frameH} = computePuzzleFrameDims(hb, piecesX, piecesY);
        addTargetFrameRect(hb, frameW, frameH);

        // place loose pieces in trays (initial management)
        arrangeLoosePiecesInTrays();

        // initial view
        viewFitAll();
        $("puzzleCanvas").style.opacity = "1";

        // stage pan should be enabled when running
        game.running = true;
        game.paused = false;

        // apply edges-only default = false
        setEdgesOnlyMode(false);

        // enable interactions
        setInteraction(true);

        // update controls
        disableControlsDisabledState();

        // start timer
        setStatus("info","En juego","Arrastra piezas. (Conexiones incorrectas desactivadas).");
        startTimer();

        // cleanup object URL (dataUrl is kept for box top)
        URL.revokeObjectURL(imgUrl);

      }catch(err){
        stopTimer();
        setStatus("danger","Error","No se pudo inicializar el puzzle.");
        showModal({
          title: "Error",
          bodyHTML: `<p>${escapeHtml(err.message || String(err))}</p>
            <p class="small">
              Si el error es <b>“Headbreaker no se pudo cargar”</b>, en GitHub Pages usa HTTPS y revisa Network.
              Si tu red bloquea CDNs, puedes “vendorizar” <code>headbreaker.js</code> y <code>konva.min.js</code> en tu repo.
            </p>`,
          buttons: [{label:"Cerrar", kind:"primary", onClick: closeModal}]
        });
      }
    }

    /* Keyboard shortcuts */
    document.addEventListener("keydown", (e) => {
      if(e.repeat) return;

      // If modal is open, only Esc handled elsewhere.
      if(overlay.getAttribute("aria-hidden") === "false"){
        return;
      }

      const k = (e.key || "").toLowerCase();
      if(k === "t"){ e.preventDefault(); cycleTheme(); }
      if(!game || !game.running) return;

      if(k === "p"){ e.preventDefault(); btnPause.click(); }
      if(k === "r"){ e.preventDefault(); btnReframe.click(); }
      if(k === "o"){ e.preventDefault(); btnOrganize.click(); }
      if(k === "e"){ e.preventDefault(); btnEdges.click(); }
      if(k === "b"){ e.preventDefault(); btnBoxTop.click(); }
      if(k === "+" || k === "="){ e.preventDefault(); btnZoomIn.click(); }
      if(k === "-" ){ e.preventDefault(); btnZoomOut.click(); }
    });

    /* Mouse wheel zoom (desktop) */
    $("canvasWrap").addEventListener("wheel", (e) => {
      if(!game || !game.running) return;
      // avoid page scroll
      e.preventDefault();
      const delta = e.deltaY > 0 ? (1/1.10) : 1.10;
      setZoom(delta);
    }, {passive:false});

    /* Initial UI state */
    disableControlsDisabledState();

  })();
  </script>
</body>
</html>

