<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Jigsaw Challenge</title>

  <!-- Motor jigsaw (CDN oficial del proyecto) -->
  <script src="https://flbulgarelli.github.io/headbreaker/js/headbreaker.js"></script>

  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 16px; }
    .grid { display: grid; grid-template-columns: 1fr; gap: 16px; max-width: 1150px; margin: 0 auto; }
    @media (min-width: 980px){ .grid { grid-template-columns: 440px 1fr; } }
    .card { border: 1px solid #ddd; border-radius: 12px; padding: 14px; }
    h2 { margin: 8px 0 12px; font-size: 18px; }
    label { display:block; margin-top: 10px; font-size: 13px; }
    input, button, select { width: 100%; padding: 10px; margin-top: 6px; box-sizing: border-box; }
    button { cursor: pointer; }
    .row { display:flex; gap: 10px; }
    .row > * { flex: 1; }
    .muted { font-size: 12px; color: #444; line-height: 1.35; }
    .sep { height: 1px; background: #eee; margin: 14px 0; }

    #hud { display:flex; gap: 10px; align-items:center; justify-content: space-between; margin-bottom: 10px; }
    #status { font-weight: 600; }
    #timer { font-variant-numeric: tabular-nums; }

    #puzzleWrap { position: relative; min-height: 560px; }
    #puzzle { width: 100%; height: 100%; }

    #overlay {
      position:absolute; inset:0;
      display:none; align-items:center; justify-content:center;
      background: rgba(0,0,0,0.78); color:#fff;
      text-align:center; padding: 16px;
      border-radius: 12px;
      pointer-events: all;
    }
    #overlay.active { display:flex; }

    #revealImg {
      max-width: 92%; max-height: 92%;
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
      display:none;
    }
    #revealImg.active { display:block; }
    .pill { display:inline-block; padding: 2px 8px; border: 1px solid #ddd; border-radius: 999px; font-size: 12px; }
  </style>
</head>
<body>

<div class="grid">
  <div class="card">
    <h2>Crear reto (tú)</h2>

    <label>Foto</label>
    <input id="createImage" type="file" accept="image/*" />

    <div class="row">
      <div>
        <label>Piezas X</label>
        <input id="piecesX" type="number" min="2" max="30" value="6" />
      </div>
      <div>
        <label>Piezas Y</label>
        <input id="piecesY" type="number" min="2" max="30" value="5" />
      </div>
    </div>

    <label>Tiempo límite para resolver (segundos)</label>
    <input id="solveSeconds" type="number" min="10" max="7200" value="300" />

    <label>Tiempo para ver la foto al ganar (segundos)</label>
    <input id="revealSeconds" type="number" min="1" max="600" value="10" />

    <div class="row">
      <div>
        <label>Max tamaño imagen (px, recomendado)</label>
        <input id="maxDim" type="number" min="600" max="4000" value="1600" />
      </div>
      <div>
        <label>Calidad JPEG (0.5–1.0)</label>
        <input id="jpegQ" type="number" min="0.5" max="1.0" step="0.05" value="0.9" />
      </div>
    </div>

    <label>Contraseña (para cifrar el reto)</label>
    <input id="createPass" type="password" placeholder="mín. 8 caracteres" />

    <button id="btnCreate">Generar archivo de reto (.jpuz)</button>
    <a id="downloadLink" style="display:none;margin-top:10px;display:block;">Descargar reto</a>

    <div class="sep"></div>

    <h2>Jugar reto (la otra persona)</h2>

    <label>Archivo .jpuz</label>
    <input id="playFile" type="file" accept=".jpuz,application/json" />

    <label>Contraseña</label>
    <input id="playPass" type="password" />

    <div class="row">
      <button id="btnStart">Empezar</button>
      <button id="btnReset" type="button">Reiniciar</button>
    </div>

    <p class="muted">
      Privacidad: la foto va dentro del .jpuz cifrada y se descifra solo en el navegador.
      WebCrypto requiere HTTPS; GitHub Pages cumple ese requisito. :contentReference[oaicite:7]{index=7}
    </p>
  </div>

  <div class="card">
    <div id="hud">
      <div id="status">Estado: esperando…</div>
      <div id="timer" class="pill">Tiempo: —</div>
    </div>

    <div id="puzzleWrap">
      <div id="puzzle"></div>
      <div id="overlay"></div>
      <img id="revealImg" alt="Revelado" />
    </div>
  </div>
</div>

<script>
  // =========================
  // Base64 helpers
  // =========================
  function ab2b64(ab) {
    const bytes = new Uint8Array(ab);
    let bin = "";
    for (let i = 0; i < bytes.length; i++) bin += String.fromCharCode(bytes[i]);
    return btoa(bin);
  }
  function b642ab(b64) {
    const bin = atob(b64);
    const bytes = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);
    return bytes.buffer;
  }

  // =========================
  // WebCrypto (PBKDF2 -> AES-GCM)
  // =========================
  const KDF_ITERS = 150000;

  async function deriveKey(pass, salt) {
    const enc = new TextEncoder();
    // PBKDF2 params en deriveKey están documentados en MDN. :contentReference[oaicite:8]{index=8}
    const keyMaterial = await crypto.subtle.importKey(
      "raw", enc.encode(pass), { name: "PBKDF2" }, false, ["deriveKey"]
    );
    return crypto.subtle.deriveKey(
      { name: "PBKDF2", salt, iterations: KDF_ITERS, hash: "SHA-256" },
      keyMaterial,
      { name: "AES-GCM", length: 256 },
      false,
      ["encrypt", "decrypt"]
    );
  }

  async function encryptPayload(pass, payloadObj) {
    const salt = crypto.getRandomValues(new Uint8Array(16));
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const key = await deriveKey(pass, salt);

    const enc = new TextEncoder();
    const plaintext = enc.encode(JSON.stringify(payloadObj));
    const ciphertext = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, plaintext);

    return {
      v: 1,
      kdf: "PBKDF2-SHA256",
      iter: KDF_ITERS,
      alg: "AES-GCM-256",
      salt: ab2b64(salt.buffer),
      iv: ab2b64(iv.buffer),
      ct: ab2b64(ciphertext)
    };
  }

  async function decryptPayload(pass, pkg) {
    const salt = new Uint8Array(b642ab(pkg.salt));
    const iv = new Uint8Array(b642ab(pkg.iv));
    const key = await deriveKey(pass, salt);

    const ct = b642ab(pkg.ct);
    // Ejemplos de cifrado/descifrado con PBKDF2 están en MDN (concepto y flujo). :contentReference[oaicite:9]{index=9}
    const plaintext = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, ct);

    const dec = new TextDecoder();
    return JSON.parse(dec.decode(plaintext));
  }

  // =========================
  // Imagen: carga + reescalado a JPEG
  // =========================
  function loadImageFromFile(file) {
    return new Promise((resolve, reject) => {
      const url = URL.createObjectURL(file);
      const img = new Image();
      img.onload = () => { URL.revokeObjectURL(url); resolve(img); };
      img.onerror = () => reject(new Error("No se pudo leer la imagen."));
      img.src = url;
    });
  }

  function canvasToBlob(canvas, type, quality) {
    return new Promise((resolve) => canvas.toBlob(resolve, type, quality));
  }

  async function fileToCompressedJpegBytes(file, maxDim, quality) {
    const img = await loadImageFromFile(file);
    const w = img.naturalWidth;
    const h = img.naturalHeight;

    const scale = Math.min(1, maxDim / Math.max(w, h));
    const tw = Math.max(1, Math.round(w * scale));
    const th = Math.max(1, Math.round(h * scale));

    const c = document.createElement("canvas");
    c.width = tw; c.height = th;
    const ctx = c.getContext("2d", { alpha: false });
    ctx.drawImage(img, 0, 0, tw, th);

    const blob = await canvasToBlob(c, "image/jpeg", quality);
    if (!blob) throw new Error("No se pudo comprimir la imagen.");
    return await blob.arrayBuffer();
  }

  // =========================
  // UI + Game state
  // =========================
  const statusEl = document.getElementById("status");
  const timerEl = document.getElementById("timer");
  const overlayEl = document.getElementById("overlay");
  const revealImgEl = document.getElementById("revealImg");

  let countdown = null;
  let solved = false;
  let canvasHB = null;

  function setStatus(s) { statusEl.textContent = "Estado: " + s; }
  function showOverlay(html) {
    overlayEl.innerHTML = html;
    overlayEl.classList.add("active");
  }
  function hideOverlay() {
    overlayEl.classList.remove("active");
    overlayEl.innerHTML = "";
  }
  function stopCountdown() {
    if (countdown) clearInterval(countdown);
    countdown = null;
  }
  function formatMMSS(totalSeconds) {
    const m = Math.floor(totalSeconds / 60);
    const s = totalSeconds % 60;
    return `${m}:${String(s).padStart(2,"0")}`;
  }

  function hardResetBoard() {
    solved = false;
    stopCountdown();
    timerEl.textContent = "Tiempo: —";
    hideOverlay();
    revealImgEl.classList.remove("active");
    revealImgEl.src = "";
    document.getElementById("puzzle").innerHTML = "";
    canvasHB = null;
    setStatus("esperando…");
  }

  document.getElementById("btnReset").addEventListener("click", hardResetBoard);

  // =========================
  // Crear reto: genera .jpuz cifrado
  // =========================
  document.getElementById("btnCreate").addEventListener("click", async () => {
    try {
      if (!crypto?.subtle) {
        // SubtleCrypto requiere contexto seguro (HTTPS). :contentReference[oaicite:10]{index=10}
        throw new Error("WebCrypto no disponible. Abre la web por HTTPS (GitHub Pages).");
      }

      const file = document.getElementById("createImage").files[0];
      const x = Number(document.getElementById("piecesX").value);
      const y = Number(document.getElementById("piecesY").value);
      const solveSeconds = Number(document.getElementById("solveSeconds").value);
      const revealSeconds = Number(document.getElementById("revealSeconds").value);
      const maxDim = Number(document.getElementById("maxDim").value);
      const jpegQ = Number(document.getElementById("jpegQ").value);
      const pass = document.getElementById("createPass").value;

      if (!file) throw new Error("Selecciona una foto.");
      if (!pass || pass.length < 8) throw new Error("Contraseña mínima: 8 caracteres.");
      if (!(x >= 2 && x <= 30 && y >= 2 && y <= 30)) throw new Error("Piezas X/Y fuera de rango.");
      if (!(solveSeconds >= 10 && solveSeconds <= 7200)) throw new Error("Tiempo límite fuera de rango.");
      if (!(revealSeconds >= 1 && revealSeconds <= 600)) throw new Error("Tiempo de revelado fuera de rango.");

      setStatus("procesando imagen…");
      const imgBytes = await fileToCompressedJpegBytes(file, maxDim, jpegQ);

      const payload = {
        mime: "image/jpeg",
        img: ab2b64(imgBytes),
        piecesX: x,
        piecesY: y,
        solveSeconds,
        revealSeconds
      };

      setStatus("cifrando…");
      const pkg = await encryptPayload(pass, payload);

      const blob = new Blob([JSON.stringify(pkg)], { type: "application/json" });
      const url = URL.createObjectURL(blob);

      const a = document.getElementById("downloadLink");
      a.href = url;
      a.download = "reto.jpuz";
      a.style.display = "block";
      a.textContent = "Descargar reto.jpuz";

      setStatus("reto generado. Envía el .jpuz + contraseña.");
    } catch (e) {
      setStatus("error: " + e.message);
    }
  });

  // =========================
  // Jugar reto: descifra y lanza puzzle con cuenta atrás
  // =========================
  document.getElementById("btnStart").addEventListener("click", async () => {
    try {
      if (!crypto?.subtle) throw new Error("WebCrypto no disponible (requiere HTTPS)."); // :contentReference[oaicite:11]{index=11}

      const file = document.getElementById("playFile").files[0];
      const pass = document.getElementById("playPass").value;
      if (!file) throw new Error("Selecciona el archivo .jpuz.");
      if (!pass) throw new Error("Introduce la contraseña.");

      hardResetBoard();
      setStatus("descifrando…");

      const pkg = JSON.parse(await file.text());
      const payload = await decryptPayload(pass, pkg);

      // Construye imagen desde base64
      const img = new Image();
      img.src = `data:${payload.mime};base64,${payload.img}`;

      img.onload = () => {
        // (Re)crear tablero
        const puzzleDiv = document.getElementById("puzzle");
        puzzleDiv.innerHTML = "";

        const wrap = document.getElementById("puzzleWrap");
        const availableW = Math.max(480, wrap.clientWidth - 10);

        // Tamaño de pieza aproximado en función de X
        const pieceSize = Math.max(34, Math.floor((availableW - 60) / payload.piecesX));
        const width = pieceSize * payload.piecesX + 60;
        const height = pieceSize * payload.piecesY + 120;

        // Headbreaker: Canvas + autogenerate + adjustImages… :contentReference[oaicite:12]{index=12}
        canvasHB = new headbreaker.Canvas("puzzle", {
          width, height,
          pieceSize,
          proximity: 18,
          borderFill: 10,
          strokeWidth: 1.5,
          lineSoftness: 0.18,
          image: img,
          preventOffstageDrag: true,
          fixed: true,
          // para escalado de imagen según documentación
          maxPiecesCount: { x: payload.piecesX, y: payload.piecesY }
        });

        canvasHB.adjustImagesToPuzzleWidth();
        canvasHB.autogenerate({
          horizontalPiecesCount: payload.piecesX,
          verticalPiecesCount: payload.piecesY
        });
        canvasHB.shuffle(0.8);
        canvasHB.draw();

        // Detección de resuelto (validador + onValid). :contentReference[oaicite:13]{index=13}
        canvasHB.attachSolvedValidator();
        canvasHB.onValid(() => {
          if (solved) return;
          solved = true;
          stopCountdown();

          setStatus("resuelto a tiempo. revelando…");
          revealImgEl.src = img.src;
          revealImgEl.classList.add("active");
          showOverlay(`<div>
            <h2>Correcto</h2>
            <p>Foto completa visible durante <b>${payload.revealSeconds}s</b>.</p>
          </div>`);

          setTimeout(() => {
            revealImgEl.classList.remove("active");
            showOverlay(`<div><h2>Fin</h2><p>Reto completado.</p></div>`);
            setStatus("finalizado.");
          }, payload.revealSeconds * 1000);
        });

        // Cuenta atrás
        let remaining = payload.solveSeconds;
        timerEl.textContent = "Tiempo: " + formatMMSS(remaining);
        setStatus("en juego…");

        countdown = setInterval(() => {
          if (solved) return;
          remaining -= 1;
          timerEl.textContent = "Tiempo: " + formatMMSS(Math.max(0, remaining));

          if (remaining <= 0) {
            stopCountdown();
            showOverlay(`<div>
              <h2>Tiempo agotado</h2>
              <p>No se completó el puzzle dentro del límite.</p>
              <p>Puedes pulsar <b>Reiniciar</b> y volver a intentar.</p>
            </div>`);
            setStatus("fallo por tiempo.");
          }
        }, 1000);
      };

      img.onerror = () => setStatus("error: no se pudo cargar la imagen descifrada.");
    } catch (e) {
      setStatus("error: " + e.message);
    }
  });
</script>

</body>
</html>

